---
title: "Illusion Game Validation (Study 2)"
output: html_document
date: "`r Sys.Date()`"
editor_options: 
  chunk_output_type: console
---

```{r, echo = FALSE, warning=FALSE, message=FALSE}
options(
  digits = 3,
  mc.cores = 4,
  brms.algorithm = "sampling",
  brms.backend = "cmdstanr"
)

cache <- TRUE
runModels <- FALSE
bestModels <- TRUE
fig.width <- see::golden_ratio(7)
fig.height <- 7

knitr::opts_chunk$set(
  collapse = TRUE,
  dpi = 450,
  fig.path = "./figures/",
  fig.width = fig.width,
  fig.height = fig.height
)
```



# Preprocessing


```{r eval=FALSE, message=FALSE, warning=FALSE, include=FALSE}
# PREPROCESSING ================================================================
source("preprocessing.R")

# This is a local folder containing raw data from unzipped pavlovia
# It has been added to .gitignore to NOT be published on github
# (it contains the subject ID of the participants)
participants <- list.files("data/")

df <- data.frame()
for (ppt in participants) {
  df <- rbind(df, preprocess_raw(file = paste0("data/", ppt)))
}

df$Pyllusion <- "1.2"

# Fix due to technical issue in the paradigm on the first day
df[df$Illusion_Type == "Rod-Frame" & df$Date == "05/08/2022", "Illusion_Strength"] <- -1 * (df[df$Illusion_Type == "Rod-Frame" & df$Date == "05/08/2022", "Illusion_Strength"])
df[df$Illusion_Type == "Rod-Frame" & df$Date == "05/08/2022", "Illusion_Effect"] <- ifelse(sign(df[df$Illusion_Type == "Rod-Frame" & df$Date == "05/08/2022", "Illusion_Strength"]) == -1, "Congruent", "Incongruent")

# Anonymize
replacement <- paste0("S", str_pad(1:length(unique(df$Participant)), 2, pad = "0"))
names(replacement) <- unique(df$Participant)
df$Participant <- replacement[df$Participant]


# Save anonymized data
write.csv(df[1:150000, ], "../data/study2_part1.csv", row.names = FALSE)
write.csv(df[150001:nrow(df), ], "../data/study2_part2.csv", row.names = FALSE)
```


```{r message=FALSE, warning=FALSE}
library(tidyverse)
library(ggdist)
library(ggside)
library(easystats)
library(patchwork)
library(brms)
source("functions.R")

df <- read.csv("../data/study2_part1.csv") |>
  rbind(read.csv("../data/study2_part2.csv")) |> 
  mutate(
    Date = lubridate::dmy(Date),
    Participant = fct_reorder(Participant, Date),
    Screen_Refresh = as.character(Screen_Refresh),
    Illusion_Side = as.factor(Illusion_Side),
    # Illusion_Effect = fct_relevel(as.factor(Illusion_Effect), "Incongruent", "Null", "Congruent"),
    Illusion_Effect = fct_relevel(as.factor(Illusion_Effect), "Incongruent", "Congruent"),
    Block = as.factor(Block),
    Education = fct_relevel(Education, "High School", "Bachelor", "Master", "Doctorate", "Other", "Prefer not to Say")
  )

# Fix precision
for(ill in unique(df$Illusion_Type)) {
  data <- df[df$Illusion_Type == ill, ] 
  i <- 10
  while (length(sort(unique(signif(data$Illusion_Difference, i)))) != 8) {
    i <- i - 1
  }
  df[df$Illusion_Type == ill, "Illusion_Difference"] <- signif(df[df$Illusion_Type == ill, "Illusion_Difference"], i)
  if (i != 10) {
    message(ill, ": Illusion_Difference values != 8. Rounded to ", i, ".")
  }
}

# Transformation
df <- df |> 
  mutate(    
    Illusion_Difference_log = log(1 + Illusion_Difference),
    Illusion_Difference_sqrt = sqrt(Illusion_Difference),
    Illusion_Difference_cbrt = Illusion_Difference**(1 / 3),
    Illusion_Strength_log = sign(Illusion_Strength) * log(1 + abs(Illusion_Strength)),
    Illusion_Strength_sqrt = sign(Illusion_Strength) * sqrt(abs(Illusion_Strength)),
    Illusion_Strength_cbrt = sign(Illusion_Strength) * (abs(Illusion_Strength)**(1 / 3))
    )
```


## Exclusions {.tabset}

```{r message=FALSE, warning=FALSE}
# plot(estimate_density(dfraw[dfraw$Participant == "60684f29dbfe1bb2059e5e27_rkqoy", "RT"]))

# Dear participant, thank you for participating in our studfy. Unfortunately, we didn't receive your data :( did something happen? Some technical issue? We would like to kindly ask you to return your participation so that we can open up more slots. Thank you in advance, and apologies for the inconvenience! 

# Dear participant, thank you for participating in our study. Unfortunately, our system detected multiple issues in your data (such as implausibly short responses, and random-like pattern of answers), which makes it unusable. We understand that you might have been in a hurry or had some other issues; we hope to open-up more slots in the future would you be interested to participate again.

# Dear participant, thank you for participating in our study. Unfortunately, our system detected multiple issues in your data (such as implausibly short responses, and random-like pattern of answers - in particular in the 2nd part of the study), which makes it unusable. We understand that you might have been in a hurry or had some other issues, and so we kindly ask you to return your participation; we hope to open-up more slots in the future would you be interested to participate again.

# Just received the results: in your case, the three most prominent issues were your response pattern that was equivalent to random (in the sequence of keystrokes) that led to a chance-level performance (that was also significantly different from the rest of the population). Moreover, your reaction time distribution was also very different from the norm, with a vast majority of implausibly short responses (i.e., that are faster than the time it takes the brain to process a visual input). This issue was even more prominent in the second block (after the break), which typically happens when participants are in a rush to finish. Finally, your overall completion time was also significantly below the average. Again, we apologize, we understand that your time is valuable, but unfortunately we run too on limited funds and can hardly spare more on unusable data. Sorry for the inconvenience, we will try to open-up more slots soon.


outliers <- c(
  # Error rate of 48.8% Very short RT
  # Prolific Status: REJECTED (06/08)
  "S46",
  # 2nd block of responses very fast
  # Prolific Status: REJECTED (15/08)
  "S221",
  # Error rate of 44% and very short RTs
  # Prolific Status: RETURN REQUESTED (22/08)
  "S154",
  # 2nd block bad, first block 1/3 bad
  # Prolific Status: RETURN REQUESTED (26/08)
  "S68",
  # Prolific Status: RETURN REQUESTED (26/08)
  "S238",
  # Prolific status: accepted (not enough proof)
  "S201"
)

partial_outliers <- c(
  # 2nd block a bit bad
  "S22", 
  # Entire 2nd block bad
  "S235",
  # Entire 2nd block bad
  "S107",
  # Half of 2nd block bad
  "S204",
  # 2nd block not good
  "S140")
```

We removed `r length(outliers)` participants upon inspection of the average error rage (when close to 50%, suggesting random answers) and/or when the reaction time distribution was implausibly fast. 

For each block, we computed the error rate and, if more than 50%, we discarded the whole block (as it likely indicates that instructions got mixed up, for instance participants were selecting the smaller instead of the bigger circle).



### Summary

```{r message=FALSE, warning=FALSE}
dfsub <- df |>
  group_by(Participant) |>
  summarize(
    # n = n(),
    Error = sum(Error) / n(),
    RT_Mean = mean(RT),
    RT_SD = sd(RT),
    IPIP6_SD = mean(IPIP6_SD),
    PID5_SD = mean(PID5_SD),
  ) |>
  ungroup() |>
  arrange(desc(Error))
```

See the next tab for the descriptive table.

### Descriptive Table


```{r message=FALSE, warning=FALSE}
data.frame(Participant = c("Total"), t(sapply(dfsub[2:ncol(dfsub)], mean, na.rm=TRUE))) |> 
  rbind(dfsub) |> 
  knitr::kable() |>
  kableExtra::row_spec(1, italic = TRUE) |> 
  kableExtra::row_spec(which(dfsub$Participant %in% outliers) + 1, background = "#EF9A9A") |> 
  kableExtra::row_spec(which(dfsub$Participant %in% partial_outliers) + 1, background = "#FFECB3")
```



### Reaction Time Distribution


```{r outliers_RT, message=FALSE, warning=FALSE, fig.width=20, fig.height=20, cache=cache}
# RT distribution
p <- df |> 
  filter(RT < 10000) |> 
  estimate_density(select = "RT", at = c("Participant", "Block")) |>
  group_by(Participant) |>
  normalize(select = "y") |>
  ungroup() |>
  mutate(Participant = fct_relevel(Participant, as.character(dfsub$Participant))) |> 
  mutate(color = ifelse(Participant %in% outliers, "red", ifelse(Participant %in% partial_outliers, "orange", "blue"))) |>
  ggplot(aes(x = x, y = y)) +
  geom_area(data = normalize(estimate_density(filter(df, RT < 10000), select = "RT"), select = "y"), alpha = 0.2) +
  geom_line(aes(color = color, group = interaction(Participant, Block), linetype = Block)) +
  geom_vline(xintercept = 125, linetype = "dashed", color = "red") +
  scale_color_manual(values = c("red" = "#F44336", "orange" = "#FF9800", "blue" = "blue"), guide = "none") +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  coord_cartesian(xlim = c(0, 3000)) +
  theme_modern() +
  theme(axis.text.y = element_blank()) +
  facet_wrap(~Participant) +
  labs(y = "", x = "Reaction Time (ms)")
p
# ggsave("figures/outliers.png", p, width=25, height=25)

# Filter out
df <- filter(df, !Participant %in% outliers)
```


### Error Rate per Illusion Block

```{r outliers_errorblock, message=FALSE, warning=FALSE}
temp <- df |>
  group_by(Participant, Illusion_Type, Block) |>
  summarize(ErrorRate_per_block = sum(Error) / n()) |>
  ungroup() |>
  arrange(desc(ErrorRate_per_block))

temp2 <- temp |>
  filter(ErrorRate_per_block >= 0.5) |>
  group_by(Illusion_Type, Block) |>
  summarize(n = n()) |>
  arrange(desc(n), Illusion_Type) |>
  ungroup() |>
  mutate(
    n_trials = cumsum(n * 56),
    p_trials = n_trials / nrow(df)
  )

# knitr::kable(temp2)

p1 <- temp |>
  estimate_density(at = c("Illusion_Type", "Block"), method="KernSmooth") |>
  ggplot(aes(x = x, y = y)) +
  geom_line(aes(color = Illusion_Type, linetype = Block)) +
  geom_vline(xintercept = 0.5, linetype = "dashed") +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  labs(y = "Distribution", x = "Error Rate") +
  theme_modern()

p2 <- temp2 |>
  mutate(Block = fct_rev(Block)) |>
  ggplot(aes(x = Illusion_Type, y = p_trials)) +
  geom_bar(stat = "identity", aes(fill = Block)) +
  scale_x_discrete(expand = c(0, 0)) +
  scale_y_continuous(labels = scales::percent, expand = c(0, 0)) +
  labs(y = "Percentage of Trials Removed", x = "Illusion Type") +
  theme_modern() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

p1 | p2


# Drop
n <- nrow(df)
df <- df |>
  group_by(Participant, Illusion_Type, Block) |>
  mutate(ErrorRate_per_block = sum(Error) / n()) |>
  ungroup() |>
  filter(ErrorRate_per_block < 0.5) |>
  select(-ErrorRate_per_block)

# Drop also participant with bad second block
df <- filter(
  df,
  !(Participant %in% partial_outliers & df$Block == 2))

rm(temp, temp2)
```

We removed `r n-nrow(df)` (`r insight::format_value((n-nrow(df)) / n, as_percent=TRUE)`) trials belonging to bad blocks.

### Reaction Time per Trial

```{r outliers_RTtrials, message=FALSE, warning=FALSE}
df <- df |>
  group_by(Participant, Error) |>
  mutate(Outlier = ifelse(Error == 0 & (RT < 125 | standardize(RT) > 4), TRUE, FALSE)) |>
  ungroup()

p1 <- df |> 
  filter(RT < 10000) |> 
  estimate_density(select = "RT", at = "Participant") |>
  group_by(Participant) |>
  normalize(select = "y") |>
  ungroup() |>
  merge(df |>
    filter(Error == 0) |>
    group_by(Participant) |>
    summarize(Outlier = mean(RT) + 4 * sd(RT))) |>
  mutate(Outlier = ifelse(x >= Outlier, TRUE, FALSE)) |>
  ggplot(aes(x = x, y = y)) +
  geom_area(data = normalize(estimate_density(filter(df, RT < 10000), select = "RT"), select = "y"), alpha = 0.2) +
  geom_line(aes(color = Participant, linetype = Outlier), alpha=0.2) +
  geom_vline(xintercept = c(125), linetype = "dashed", color = "red") +
  scale_color_material_d("rainbow", guide = "none") +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  guides(linetype = "none") +
  coord_cartesian(xlim = c(0, 4000)) +
  theme_modern() +
  theme(axis.text.y = element_blank()) +
  labs(y = "", x = "Reaction Time (ms)")


p2 <- df |>
  group_by(Participant) |>
  summarize(Outlier = sum(Outlier) / n()) |>
  mutate(Participant = fct_reorder(Participant, Outlier)) |>
  ggplot(aes(x = Participant, y = Outlier)) +
  geom_bar(stat = "identity", aes(fill = Participant)) +
  scale_fill_material_d("rainbow", guide = "none") +
  scale_x_discrete(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0), labels = scales::percent) +
  see::theme_modern() +
  theme(axis.text.x = element_blank()) +
  labs(y = "Percentage of outlier trials")

p1 / p2
```

We removed `r sum(df$Outlier)` (`r insight::format_value(sum(df$Outlier) / nrow(df), as_percent=TRUE)`) outlier trials (125 ms < RT < 4 SD above mean).

```{r message=FALSE, warning=FALSE}
df <- filter(df, Outlier == FALSE)
df$RT <- df$RT / 1000  # Convert to second for better model convergence
```



## Participants



```{r message=FALSE, warning=FALSE}
dfsub <- df |>
  group_by(Participant) |>
  select(Participant, Age, Sex, Ethnicity, Education, Nationality, Duration, Break_Duration, Device_OS, starts_with("Screen"), starts_with("IPIP6"), starts_with("PID5")) |>
  slice(1) |>
  ungroup()
```

The final sample included `r report::report_participants(dfsub, age="Age", sex="Sex")`.


```{r demographics, fig.width=20, fig.height=15}
p1 <- plot_distribution(dfsub, "Age", fill = "#FF9800")
p2 <- plot_distribution(dfsub, "Duration", title = "Total Duration", subtitle = "in minutes", fill = "#F44336")
p3 <- plot_distribution(dfsub[dfsub$Break_Duration < 3, ], "Break_Duration", title = "Break Duration", subtitle = "in minutes", fill = "#3F51B5")

p4 <- plot_waffle(dfsub, "Sex") +
  scale_color_manual(values = c("Male" = "#2196F3", "Female" = "#E91E63", "Other" = "#FF9800"))

p5 <- plot_waffle(dfsub, "Education") +
  scale_color_viridis_d()

p6 <- plot_waffle(dfsub, "Nationality") +
  scale_color_material_d()
  # scale_fill_manual(values = c("South American" = "#FF5722", "Middle Eastern" = "#FF9800", "Western" = "#2196F3", "Eastern" = "#673AB7", "African" = "#4CAF50", "South African" = "#009688"))

p7 <- plot_waffle(dfsub, "Ethnicity") +
  scale_color_manual(values = c("Latino" = "#FF5722", "Caucasian" = "#2196F3", "African" = "#4CAF50", "Other" = "#795548"))

p8 <- plot_waffle(dfsub, "Screen_Resolution", title = "Screen Resolution") +
  scale_color_pizza_d() +
  guides(fill = "none")

p9 <- plot_waffle(dfsub, "Device_OS", title = "Device OS") +
  scale_color_bluebrown_d()

# p10 <- plot_waffle(dfsub, "Screen_Refresh") +
#   scale_fill_viridis_d()

(p1 / p2) | (p4 / p5 / p9) | (p6 / p7 / p8)
```





# Results


```{r test_ISI, eval=FALSE, message=FALSE, warning=FALSE}
# Test where ISI needs to be included
rez <- data.frame()
for(ill in c("Delboeuf", 
             "Ebbinghaus", 
             "Rod-Frame",
             "Vertical-Horizontal", 
             "Zöllner",
             "White",
             "Müller-Lyer", 
             "Ponzo", 
             "Poggendorff",
             "Contrast")) {
  print(ill)
  print("===================")
  m1 <- brms::brm(
    Error ~ poly(ISI, 2) + (poly(ISI, 2) | Participant),
    data = filter(df, Illusion_Type == ill),
    family = "bernoulli",
    algorithm="meanfield"
  )
  m2 <- brms::brm(
    brms::bf(
      RT ~ poly(ISI, 2) + (1 | Participant),
      sigma ~ poly(ISI, 2),
      beta ~ poly(ISI, 2)
    ),
    data = filter(df, Illusion_Type == ill, Error == 0),
    family = "exgaussian",
    init=0,
    iter = 4000,
    algorithm="meanfield"
  )
  rez <- rbind(
    bayestestR::describe_posterior(as.data.frame(m1))[2:3, ],
    bayestestR::describe_posterior(as.data.frame(m2))[4:9, ]
  ) |> 
    mutate(Illusion = ill) |> 
    rbind(rez)
}
```


```{r make_GAMs, eval=FALSE, message=FALSE, warning=FALSE}
for(ill in c("Delboeuf", 
             "Ebbinghaus", 
             "Rod-Frame",
             "Vertical-Horizontal", 
             "Zöllner",
             "White",
             "Müller-Lyer", 
             "Ponzo", 
             "Poggendorff",
             "Contrast")) {
  print(ill)
  model <- brms::brm(
    Error ~ t2(Illusion_Difference, Illusion_Strength, k=8, bs="cr") + (1 | Participant),
    data = filter(df, Illusion_Type == ill),
    family = "bernoulli",
    algorithm="sampling"
  )

  name <- paste0("gam_", tolower(clean_illusionName(ill)), "_err")
  assign(name, model)  # Rename with string
  save(list=name, file=paste0("models/", name, ".Rdata"))
  
  model <- brms::brm(
    brms::bf(
      RT ~ t2(Illusion_Difference, Illusion_Strength, k=8, bs="cr") + poly(ISI, 2) + (1 | Participant),
      sigma ~ t2(Illusion_Difference, Illusion_Strength, k=8, bs="cr") + poly(ISI, 2) + (1 | Participant),
      beta ~ t2(Illusion_Difference, Illusion_Strength, k=8, bs="cr") + poly(ISI, 2) + (1 | Participant)
    ),
    data = filter(df, Illusion_Type == ill, Error == 0),
    family = "exgaussian",
    init=0,
    algorithm="sampling"
  )
  
  name <- paste0("gam_", tolower(clean_illusionName(ill)), "_rt")
  assign(name, model)  # Rename with string
  save(list=name, file=paste0("models/", name, ".Rdata"))
}
```


## Models {.tabset}


### Delboeuf

#### Model Selection

```{r message=FALSE, warning=FALSE, cache=cache}
data <- filter(df, Illusion_Type == "Delboeuf")

# mm <- model.matrix(Error ~ abs(Illusion_Strength) * Illusion_Effect, data=data)
# head(as.data.frame(mm))
```

```{r bestmodels_delboeuf, message=FALSE, warning=FALSE, cache=cache, eval=bestModels}
best_models(data)

# m1 <- glmmTMB::glmmTMB(Error ~ sqrt(Illusion_Difference) * sqrt(abs(Illusion_Strength)) * Illusion_Effect + (1 | Participant), data = data, family = "binomial")
# m2 <- glmmTMB::glmmTMB(Error ~ sqrt(Illusion_Difference) * sqrtmod(Illusion_Strength) + (1 | Participant), data = data, family = "binomial")
# 
# compare_performance(m1, m2, metrics = c("R2", "BIC"))
# test_performance(m1, m2)
```


#### Error Rate 

##### Descriptive

```{r message=FALSE, warning=FALSE, cache=cache}
plot_descriptive_err(data)
```



##### Model Specification


```{r m_err_delboeuf, message=FALSE, warning=FALSE, eval=runModels}
formula <- brms::bf(
  Error ~ Illusion_Effect / (sqrt(Illusion_Difference) * sqrt(abs(Illusion_Strength))) +
    (1 + Illusion_Effect / (sqrt(Illusion_Difference) * sqrt(abs(Illusion_Strength))) | Participant),
  family = "bernoulli"
)

# brms::get_prior(formula, data = data)
# brms::validate_prior(formula)

model_delboeuf_err <- brms::brm(formula,
  data = data,
  refresh = 100
)

save(model_delboeuf_err, file="models/model_delboeuf_err.Rdata")
```
```{r message=FALSE, warning=FALSE, eval=TRUE}
load("models/model_delboeuf_err.RData")
load("models/gam_delboeuf_err.RData")

# parameters::parameters(model_delboeuf_err)
```


##### Model Visualization


```{r message=FALSE, warning=FALSE, cache=cache}
p_delboeuf_err <- plot_model_err(data, model_delboeuf_err, gam_delboeuf_err)
p_delboeuf_err
```



#### Reaction Time

##### Descriptive

```{r message=FALSE, warning=FALSE, cache=cache}
data <- filter(df, Illusion_Type == "Delboeuf", Error == 0)

plot_descriptive_rt(data)
```

##### Model Specification

```{r m_rt_delboeuf, message=FALSE, warning=FALSE, cache=cache, eval=FALSE}
formula <- brms::bf(
  RT ~ Illusion_Effect / (sqrt(Illusion_Difference) * logmod(abs(Illusion_Strength))) +  
    poly(ISI, 2) +
    (1 + Illusion_Effect / (sqrt(Illusion_Difference) * logmod(abs(Illusion_Strength))) | Participant),
  sigma ~ Illusion_Effect / (sqrt(Illusion_Difference) * logmod(abs(Illusion_Strength))) +  
    poly(ISI, 2) + (1 | Participant),
  beta ~ Illusion_Effect / (sqrt(Illusion_Difference) * logmod(abs(Illusion_Strength))) +  
    poly(ISI, 2) + (1 | Participant),
  family = "exgaussian"
)


# brms::get_prior(formula, data = data)
# plot(seq(-5, 5, length.out=100), brms::dstudent_t(seq(-5, 5, length.out=100), df = 3, 0.1, 0.5))
# priors <- c(
  # Intercept
  # prior("student_t(3, 0, 0.1)", class = "Intercept"),
  # prior("student_t(3, 0.35, 0.1)", class = "sd", coef="Intercept", group="Participant"),
  # Default parameters
  # prior("student_t(3, 0, 3)", class = "b"),
  # prior("student_t(3, 0.35, 0.5)", class = "sd", group="Participant")
  
  # prior("student_t(3, 0, 1)", class="Intercept", dpar = "sigma"),
  # prior("student_t(3, 0.1, 1)", class="sd", dpar = "sigma")
  
  # prior("student_t(3, 0.1, 0.5)", class = "ndt")
  # ) |> 
  # brms::validate_prior(formula, data = data)

# bayestestR::model_to_priors(model_delboeuf_rt, scale_multiply=3)

model_delboeuf_rt <- brms::brm(formula,
  data = data,
  refresh = 100,
  init=0
)

save(model_delboeuf_rt, file="models/model_delboeuf_rt.Rdata")
```
```{r message=FALSE, warning=FALSE, cache=cache, eval=TRUE}
load("models/model_delboeuf_rt.RData")
load("models/gam_delboeuf_rt.RData")

# performance::check_model(model_delboeuf_rt)
# parameters::parameters(model)
```


##### Model Visualization


```{r message=FALSE, warning=FALSE, cache=cache, eval=FALSE}
plot_ppcheck(model_delboeuf_rt, gam_delboeuf_rt)

p_delboeuf_rt <- plot_model_rt(data, model_delboeuf_rt, gam_delboeuf_rt)
p_delboeuf_rt
```


#### Visualization

```{r message=FALSE, warning=FALSE, cache=cache, fig.height=fig.height*2, eval=FALSE}
p_delboeuf <- plot_all(data, p_delboeuf_err, p_delboeuf_rt)
p_delboeuf
```


### Ebbinghaus

#### Model Selection

```{r message=FALSE, warning=FALSE, cache=cache}
data <- filter(df, Illusion_Type == "Ebbinghaus") 
```

```{r message=FALSE, warning=FALSE, cache=cache, eval=bestModels}
best_models(data)

# m1 <- glmmTMB::glmmTMB(Error ~ sqrt(Illusion_Difference) * logmod(abs(Illusion_Strength)) * Illusion_Effect +
#     (1 | Participant), data = data, family = "binomial")
# m2 <- glmmTMB::glmmTMB(Error ~ sqrt(Illusion_Difference) * logmod(Illusion_Strength) +
#     (1 | Participant), data = data, family = "binomial")
# 
# test_performance(m1, m2)
# compare_performance(m1, m2)
```


#### Error Rate 

##### Descriptive

```{r message=FALSE, warning=FALSE, cache=cache}
plot_descriptive_err(data)
```



##### Model Specification

```{r m_err_ebbinghaus, message=FALSE, warning=FALSE, eval=runModels}
formula <- brms::bf(
  Error ~ Illusion_Effect / (sqrt(Illusion_Difference) * abs(Illusion_Strength)) +
    (1 + Illusion_Effect / (sqrt(Illusion_Difference) * abs(Illusion_Strength)) | Participant),
  family = "bernoulli"
)

# brms::get_prior(formula, data = data)
# brms::validate_prior(formula)

model_ebbinghaus_err <- brms::brm(formula,
  data = data,
  refresh = 100
)

save(model_ebbinghaus_err, file="models/model_ebbinghaus_err.Rdata")
```
```{r message=FALSE, warning=FALSE, cache=cache}
load("models/model_ebbinghaus_err.RData")
load("models/gam_ebbinghaus_err.RData")

# parameters::parameters(model_delboeuf_err)
```


##### Model Visualization


```{r message=FALSE, warning=FALSE, cache=cache}
p_ebbinghaus_err <- plot_model_err(data, model_ebbinghaus_err, gam_ebbinghaus_err)
p_ebbinghaus_err
```



#### Reaction Time

##### Descriptive

```{r message=FALSE, warning=FALSE, cache=cache}
data <- filter(df, Illusion_Type == "Ebbinghaus", Error == 0)

plot_descriptive_rt(data)
```


##### Model Specification

```{r m_rt_ebbinghaus, message=FALSE, warning=FALSE, cache=cache, eval=FALSE}
formula <- brms::bf(
  RT ~ Illusion_Effect / (sqrt(Illusion_Difference) * abs(Illusion_Strength)) +
    poly(ISI, 2) + 
    (1 + Illusion_Effect / (sqrt(Illusion_Difference) * abs(Illusion_Strength)) | Participant),
  sigma ~ Illusion_Effect / (sqrt(Illusion_Difference) * abs(Illusion_Strength)) + 
    poly(ISI, 2) + (1 | Participant),
  beta ~ Illusion_Effect / (sqrt(Illusion_Difference) * abs(Illusion_Strength)) + 
    poly(ISI, 2) + (1 | Participant),
  family = "exgaussian"
)


model_ebbinghaus_rt <- brms::brm(formula,
  data = data,
  refresh = 100,
  init = 0
)

save(model_ebbinghaus_rt, file="models/model_ebbinghaus_rt.Rdata")
```
```{r message=FALSE, warning=FALSE, cache=cache, eval=TRUE}
load("models/model_ebbinghaus_rt.RData")
load("models/gam_ebbinghaus_rt.RData")

# performance::check_model(model_delboeuf_rt)
# parameters::parameters(model)
```


##### Model Visualization


```{r message=FALSE, warning=FALSE, cache=cache, eval=FALSE}
plot_ppcheck(model_ebbinghaus_rt, gam_ebbinghaus_rt)

p_ebbinghaus_rt <- plot_model_rt(data, model_ebbinghaus_rt, gam_ebbinghaus_rt)
p_ebbinghaus_rt
```


#### Visualization

```{r message=FALSE, warning=FALSE, cache=cache, fig.height=fig.height*2, eval=FALSE}
p_ebbinghaus <- plot_all(data, p_ebbinghaus_err, p_ebbinghaus_rt)
p_ebbinghaus
```


### Rod and Frame

#### Model Selection

```{r message=FALSE, warning=FALSE, cache=cache}
data <- filter(df, Illusion_Type == "Rod-Frame")
```

```{r message=FALSE, warning=FALSE, cache=cache, eval=bestModels}
best_models(data)

m1 <- glmmTMB::glmmTMB(Error ~ logmod(Illusion_Difference) * logmod(abs(Illusion_Strength)) * Illusion_Effect +
    (1 | Participant), data = data, family = "binomial")
m2 <- glmmTMB::glmmTMB(Error ~ logmod(Illusion_Difference) * logmod(Illusion_Strength) +
    (1 | Participant), data = data, family = "binomial")

compare_performance(m1, m2)
test_performance(m1, m2)
```

#### Error Rate 

##### Descriptive

```{r message=FALSE, warning=FALSE, cache=cache}
plot_descriptive_err(data)
```


##### Model Specification

```{r m_err_rodframe, message=FALSE, warning=FALSE, eval=runModels}
formula <- brms::bf(
  Error ~ Illusion_Effect / (logmod(Illusion_Difference) * logmod(Illusion_Strength)) +
    (1 + Illusion_Effect / (logmod(Illusion_Difference) * logmod(Illusion_Strength)) | Participant),
  family = "bernoulli"
)

# brms::get_prior(formula, data = data)
# brms::validate_prior(formula)

model_rodframe_err <- brms::brm(formula,
  data = data,
  refresh = 100
)

# parameters::parameters(model_delboeuf_err)

save(model_rodframe_err, file="models/model_rodframe_err.Rdata")
```
```{r message=FALSE, warning=FALSE, cache=cache}
load("models/model_rodframe_err.RData")
load("models/gam_rodframe_err.RData")
```


##### Model Visualization


```{r message=FALSE, warning=FALSE, cache=cache}
p_rodframe_err <- plot_model_err(data, model_rodframe_err, gam_rodframe_err)
p_rodframe_err
```


#### Reaction Time

##### Descriptive

```{r message=FALSE, warning=FALSE, cache=cache}
data <- filter(df, Illusion_Type == "Rod-Frame", Error == 0)

plot_descriptive_rt(data)
```


##### Model Specification

```{r m_rt_rodframe, message=FALSE, warning=FALSE, cache=cache, eval=FALSE}
formula <- brms::bf(
  RT ~ Illusion_Effect / (logmod(Illusion_Difference) * logmod(abs(Illusion_Strength))) +
    poly(ISI, 2) + 
    (1 + Illusion_Effect / (logmod(Illusion_Difference) * logmod(abs(Illusion_Strength))) | Participant),
  sigma ~ Illusion_Effect / (logmod(Illusion_Difference) * logmod(abs(Illusion_Strength))) + 
    poly(ISI, 2) + (1 | Participant),
  beta ~ Illusion_Effect / (logmod(Illusion_Difference) * logmod(abs(Illusion_Strength))) + 
    poly(ISI, 2) + (1 | Participant),
  family = "exgaussian"
)


model_rodframe_rt <- brms::brm(formula,
  data = data,
  refresh = 100,
  init = 0
)

save(model_rodframe_rt, file="models/model_rodframe_rt.Rdata")
```
```{r message=FALSE, warning=FALSE, cache=cache, eval=TRUE}
load("models/model_rodframe_rt.RData")
load("models/gam_rodframe_rt.RData")

# performance::check_model(model_delboeuf_rt)
# parameters::parameters(model)
```


##### Model Visualization


```{r message=FALSE, warning=FALSE, cache=cache, eval=FALSE}
plot_ppcheck(model_rodframe_rt, gam_rodframe_rt)

p_rodframe_rt <- plot_model_rt(data, model_rodframe_rt, gam_rodframe_rt)
p_rodframe_rt
```


#### Visualization

```{r message=FALSE, warning=FALSE, cache=cache, fig.height=fig.height*2, eval=FALSE}
p_rodframe <- plot_all(data, p_rodframe_err, p_rodframe_rt)
p_rodframe
```



### Vertical-Horizontal

#### Model Selection

```{r message=FALSE, warning=FALSE, cache=cache}
data <- filter(df, Illusion_Type == "Vertical-Horizontal") 
```

```{r message=FALSE, warning=FALSE, cache=cache, eval=bestModels}
best_models(data)
```


#### Error Rate 

##### Descriptive

```{r message=FALSE, warning=FALSE, cache=cache}
plot_descriptive_err(data)
```


##### Model Specification

```{r m_err_verticalhorizontal, message=FALSE, warning=FALSE, eval=runModels}
formula <- brms::bf(
  Error ~ Illusion_Effect / (sqrt(Illusion_Difference) * sqrt(abs(Illusion_Strength))) +
    (1 + Illusion_Effect / (sqrt(Illusion_Difference) * sqrt(abs(Illusion_Strength))) | Participant),
  family = "bernoulli"
)

# brms::get_prior(formula, data = data)
# brms::validate_prior(formula)

model_verticalhorizontal_err <- brms::brm(formula,
  data = data,
  refresh = 100
)

save(model_verticalhorizontal_err, file="models/model_verticalhorizontal_err.Rdata")
```
```{r message=FALSE, warning=FALSE, cache=cache}
load("models/model_verticalhorizontal_err.RData")
load("models/gam_verticalhorizontal_err.RData")

# parameters::parameters(model_verticalhorizontal_err)

```


##### Model Visualization


```{r message=FALSE, warning=FALSE, cache=cache}
p_verticalhorizontal_err <- plot_model_err(data, model_verticalhorizontal_err, gam_verticalhorizontal_err)
p_verticalhorizontal_err
```



#### Reaction Time

##### Descriptive

```{r message=FALSE, warning=FALSE, cache=cache}
data <- filter(df, Illusion_Type == "Vertical-Horizontal", Error == 0)

plot_descriptive_rt(data)
```


##### Model Specification

```{r m_rt_verticalhorizontal, message=FALSE, warning=FALSE, cache=cache, eval=FALSE}
formula <- brms::bf(
  RT ~ Illusion_Effect / (sqrt(Illusion_Difference) * sqrt(abs(Illusion_Strength))) +
    poly(ISI, 2) + 
    (1 + Illusion_Effect / (sqrt(Illusion_Difference) * sqrt(abs(Illusion_Strength))) | Participant),
  sigma ~ Illusion_Effect / (sqrt(Illusion_Difference) * sqrt(abs(Illusion_Strength))) + 
    poly(ISI, 2) + (1 | Participant),
  beta ~ Illusion_Effect / (sqrt(Illusion_Difference) * sqrt(abs(Illusion_Strength))) + 
    poly(ISI, 2) + (1 | Participant),
  family = "exgaussian"
)


model_verticalhorizontal_rt <- brms::brm(formula,
  data = data,
  refresh = 100,
  init = 0
)

save(model_verticalhorizontal_rt, file="models/model_verticalhorizontal_rt.Rdata")
```
```{r message=FALSE, warning=FALSE, cache=cache, eval=FALSE}
load("models/model_verticalhorizontal_rt.RData")
load("models/gam_verticalhorizontal_rt.RData")

plot_ppcheck(model_verticalhorizontal_rt)
# performance::check_model(model_verticalhorizontal_rt)
# parameters::parameters(model)
```



##### Model Visualization


```{r message=FALSE, warning=FALSE, cache=cache, eval=FALSE}
p_verticalhorizontal_rt <- plot_model_rt(data, model_verticalhorizontal_rt, gam_verticalhorizontal_rt)
p_verticalhorizontal_rt
```



### Zöllner


#### Model Selection

```{r message=FALSE, warning=FALSE, cache=cache}
data <- filter(df, Illusion_Type == "Zöllner")
```

```{r message=FALSE, warning=FALSE, cache=cache, eval=bestModels}
best_models(data)
```

#### Error Rate 


##### Descriptive

```{r message=FALSE, warning=FALSE, cache=cache}
plot_descriptive_err(data)
```


##### Model Specification

```{r m_err_zollner, message=FALSE, warning=FALSE, eval=runModels}
formula <- brms::bf(
  Error ~ Illusion_Effect / (cbrtmod(Illusion_Difference) * abs(Illusion_Strength)) +
    (1 + Illusion_Effect / (cbrtmod(Illusion_Difference) * abs(Illusion_Strength)) | Participant),
  family = "bernoulli"
)

# brms::get_prior(formula, data = data)
# brms::validate_prior(formula)

model_zollner_err <- brms::brm(formula,
  data = data,
  refresh = 0
)

# parameters::parameters(model_zollner_err)

save(model_zollner_err, file="models/model_zollner_err.Rdata")
```
```{r message=FALSE, warning=FALSE, cache=cache}
load("models/model_zollner_err.RData")
load("models/gam_zollner_err.RData")
```


##### Model Visualization


```{r message=FALSE, warning=FALSE, cache=cache}
p_zollner_err <- plot_model_err(data, model_zollner_err, gam_zollner_err)
p_zollner_err
```


#### Reaction Time

##### Descriptive

```{r message=FALSE, warning=FALSE, cache=cache}
data <- filter(df, Illusion_Type == "Zöllner", Error == 0)

plot_descriptive_rt(data)
```



##### Model Specification

```{r m_rt_zollner, message=FALSE, warning=FALSE, cache=cache, eval=FALSE}
formula <- brms::bf(
  RT ~  Illusion_Effect / (cbrtmod(Illusion_Difference) * abs(Illusion_Strength)) +
    poly(ISI, 2) + 
    (1 + Illusion_Effect / (cbrtmod(Illusion_Difference) * abs(Illusion_Strength)) | Participant),
  sigma ~  Illusion_Effect / (cbrtmod(Illusion_Difference) * abs(Illusion_Strength)) +
    poly(ISI, 2) + (1 | Participant),
  beta ~ Illusion_Effect / (cbrtmod(Illusion_Difference) * abs(Illusion_Strength)) +
    poly(ISI, 2) + (1 | Participant),
  family = "exgaussian"
)


model_zollner_rt <- brms::brm(formula,
  data = data,
  refresh = 100,
  init = 0
)

save(model_zollner_rt, file="models/model_zollner_rt.Rdata")
```
```{r message=FALSE, warning=FALSE, cache=cache, eval=FALSE}
load("models/model_zollner_rt.RData")
load("models/gam_zollner_rt.RData")

plot_ppcheck(model_zollner_rt)
# performance::check_model(model_zollner_rt)
# parameters::parameters(model)

```


##### Model Visualization


```{r message=FALSE, warning=FALSE, cache=cache, eval=FALSE}
p_zollner_rt <- plot_model_rt(data, model_zollner_rt, gam_zollner_rt)
p_zollner_rt
```



### White


```{r message=FALSE, warning=FALSE, cache=cache}
data <- filter(df, Illusion_Type == "White")
```

```{r message=FALSE, warning=FALSE, cache=cache, eval=bestModels}
best_models(data)
```

#### Error Rate 

##### Descriptive

```{r message=FALSE, warning=FALSE, cache=cache}
plot_descriptive_err(data)
```


##### Model Specification

```{r m_err_white, essage=FALSE, warning=FALSE, eval=runModels}
formula <- brms::bf(
  Error ~ Illusion_Effect / (Illusion_Difference * sqrt(abs(Illusion_Strength))) +
    (1 + Illusion_Effect / (Illusion_Difference * sqrt(abs(Illusion_Strength))) | Participant),
  family = "bernoulli"
)

# brms::get_prior(formula, data = data)
# brms::validate_prior(formula)

model_white_err <- brms::brm(formula,
  data = data,
  refresh = 100
)

# parameters::parameters(model_white_err)

save(model_white_err, file="models/model_white_err.Rdata")
```
```{r message=FALSE, warning=FALSE, cache=cache}
load("models/model_white_err.RData")
load("models/gam_white_err.RData")
```


##### Model Visualization


```{r message=FALSE, warning=FALSE, cache=cache}
p_white_err <- plot_model_err(data, model_white_err, gam_white_err)
p_white_err
```



#### Reaction Time

##### Descriptive

```{r message=FALSE, warning=FALSE, cache=cache}
data <- filter(df, Illusion_Type == "White", Error == 0)

plot_descriptive_rt(data)
```

##### Model Specification

```{r m_rt_white, message=FALSE, warning=FALSE, cache=cache, eval=FALSE}
formula <- brms::bf(
  RT ~ Illusion_Effect / (Illusion_Difference * sqrt(abs(Illusion_Strength))) +
    poly(ISI, 2) + 
    (1 + Illusion_Effect / (Illusion_Difference * sqrt(abs(Illusion_Strength))) | Participant),
  sigma ~ Illusion_Effect / (Illusion_Difference * sqrt(abs(Illusion_Strength))) +
    poly(ISI, 2) + (1 | Participant),
  beta ~ Illusion_Effect / (Illusion_Difference * sqrt(abs(Illusion_Strength))) +
    poly(ISI, 2) + (1 | Participant),
  family = "exgaussian"
)


model_white_rt <- brms::brm(formula,
  data = data,
  refresh = 100,
  init = 0
)

save(model_white_rt, file="models/model_white_rt.Rdata")
```
```{r message=FALSE, warning=FALSE, cache=cache, eval=FALSE}
load("models/model_white_rt.RData")
load("models/gam_white_rt.RData")

plot_ppcheck(model_white_rt)
# performance::check_model(model_white_rt)
# parameters::parameters(model)
```


##### Model Visualization


```{r message=FALSE, warning=FALSE, cache=cache, eval=FALSE}
p_white_rt <- plot_model_rt(data, model_white_rt, gam_white_rt)
p_white_rt
```


### Müller-Lyer

#### Model Selection

```{r message=FALSE, warning=FALSE, cache=cache}
data <- filter(df, Illusion_Type == "Müller-Lyer")
```

```{r message=FALSE, warning=FALSE, cache=cache, eval=bestModels}
best_models(data)
```

#### Error Rate 

##### Descriptive

```{r message=FALSE, warning=FALSE, cache=cache}
plot_descriptive_err(data, side = "updown")
```



##### Model Specification

```{r m_err_mullerlyer, message=FALSE, warning=FALSE, eval=runModels}
formula <- brms::bf(
  Error ~ Illusion_Effect / (sqrt(Illusion_Difference) * sqrt(abs(Illusion_Strength))) +
    (1 + Illusion_Effect / (sqrt(Illusion_Difference) * sqrt(abs(Illusion_Strength))) | Participant),
  family = "bernoulli"
)

# brms::get_prior(formula, data = data)
# brms::validate_prior(formula)

model_mullerlyer_err <- brms::brm(formula,
  data = data,
  refresh = 100
)

# parameters::parameters(model_white_err)

save(model_mullerlyer_err, file="models/model_mullerlyer_err.Rdata")
```
```{r message=FALSE, warning=FALSE, cache=cache}
load("models/model_mullerlyer_err.RData")
load("models/gam_mullerlyer_err.RData")
```

##### Model Visualization


```{r message=FALSE, warning=FALSE, cache=cache}
p_mullerlyer_err <- plot_model_err(data, model_mullerlyer_err, gam_mullerlyer_err)
p_mullerlyer_err
```

#### Reaction Time

##### Descriptive

```{r message=FALSE, warning=FALSE, cache=cache}
data <- filter(df, Illusion_Type == "Müller-Lyer", Error == 0)

plot_descriptive_rt(data, side = "updown")
```


##### Model Specification

```{r m_rt_mullerlyer, message=FALSE, warning=FALSE, cache=cache, eval=FALSE}
formula <- brms::bf(
  RT ~ Illusion_Effect / (sqrt(Illusion_Difference) * sqrt(abs(Illusion_Strength))) +
    poly(ISI, 2) + 
    (1 + Illusion_Effect / (sqrt(Illusion_Difference) * sqrt(abs(Illusion_Strength))) | Participant),
  sigma ~ Illusion_Effect / (sqrt(Illusion_Difference) * sqrt(abs(Illusion_Strength))) +
    poly(ISI, 2) + (1 | Participant),
  beta ~ Illusion_Effect / (sqrt(Illusion_Difference) * sqrt(abs(Illusion_Strength))) + 
    poly(ISI, 2) + (1 | Participant),
  family = "exgaussian"
)


model_mullerlyer_rt <- brms::brm(formula,
  data = data,
  refresh = 100,
  init = 0
)

save(model_mullerlyer_rt, file="models/model_mullerlyer_rt.Rdata")
# parameters::parameters(model_white_err)
```
```{r message=FALSE, warning=FALSE, cache=cache, eval=FALSE}
load("models/model_mullerlyer_rt.RData")
load("models/gam_mullerlyer_rt.RData")

plot_ppcheck(model_mullerlyer_rt)
# performance::check_model(model_mullerlyer_rt)
# parameters::parameters(model)
```

##### Model Visualization


```{r message=FALSE, warning=FALSE, cache=cache, eval=FALSE}
p_mullerlyer_rt <- plot_model_rt(data, model_mullerlyer_rt, gam_mullerlyer_rt)
p_mullerlyer_rt
```


### Ponzo

#### Model Selection

```{r message=FALSE, warning=FALSE, cache=cache}
data <- filter(df, Illusion_Type == "Ponzo")
```

```{r message=FALSE, warning=FALSE, cache=FALSE, eval=bestModels}
best_models(data)
```

#### Error Rate 


##### Descriptive

```{r message=FALSE, warning=FALSE, cache=cache}
plot_descriptive_err(data, side = "updown")
```


##### Model Specification

```{r m_err_ponzo, message=FALSE, warning=FALSE, eval=runModels}
formula <- brms::bf(
  Error ~ Illusion_Effect / (cbrtmod(Illusion_Difference) * abs(Illusion_Strength)) +
    (1 + Illusion_Effect / (cbrtmod(Illusion_Difference) * abs(Illusion_Strength)) | Participant),
  family = "bernoulli"
)

# brms::get_prior(formula, data = data)
# brms::validate_prior(formula)

model_ponzo_err <- brms::brm(formula,
  data = data,
  refresh = 100
)

# parameters::parameters(model_ponzo_err)

save(model_ponzo_err, file="models/model_ponzo_err.Rdata")
```
```{r message=FALSE, warning=FALSE, cache=cache}
load("models/model_ponzo_err.RData")
load("models/gam_ponzo_err.RData")
```

##### Model Visualization


```{r message=FALSE, warning=FALSE, cache=cache}
p_ponzo_err <- plot_model_err(data, model_ponzo_err, gam_ponzo_err)
p_ponzo_err
```


#### Reaction Time

##### Descriptive

```{r message=FALSE, warning=FALSE, cache=cache}
data <- filter(df, Illusion_Type == "Ponzo", Error == 0)

plot_descriptive_rt(data, side = "updown")
```


##### Model Specification

```{r m_rt_ponzo, message=FALSE, warning=FALSE, cache=cache, eval=FALSE}
formula <- brms::bf(
  RT ~ Illusion_Effect / (cbrtmod(Illusion_Difference) * abs(Illusion_Strength)) +
    poly(ISI, 2) + 
    (1 + Illusion_Effect / (cbrtmod(Illusion_Difference) * abs(Illusion_Strength)) | Participant),
  sigma ~ Illusion_Effect / (cbrtmod(Illusion_Difference) * abs(Illusion_Strength)) +
    poly(ISI, 2) + (1 | Participant),
  beta ~ Illusion_Effect / (cbrtmod(Illusion_Difference) * abs(Illusion_Strength)) +
    poly(ISI, 2) + (1 | Participant),
  family = "exgaussian"
)


model_ponzo_rt <- brms::brm(formula,
  data = data,
  refresh = 100,
  init = 0
)

save(model_ponzo_rt, file="models/model_ponzo_rt.Rdata")
# parameters::parameters(model_white_err)
```
```{r message=FALSE, warning=FALSE, cache=cache, eval=FALSE}
load("models/model_ponzo_rt.RData")
load("models/gam_ponzo_rt.RData")

plot_ppcheck(model_ponzo_rt)
# performance::check_model(model_ponzo_rt)
# parameters::parameters(model)
```

##### Model Visualization


```{r message=FALSE, warning=FALSE, cache=cache, eval=FALSE}
p_ponzo_rt <- plot_model_rt(data, model_ponzo_rt, gam_ponzo_rt)
p_ponzo_rt
```


### Poggendorff

#### Model Selection

```{r message=FALSE, warning=FALSE, cache=cache}
data <- filter(df, Illusion_Type == "Poggendorff")
```

```{r message=FALSE, warning=FALSE, cache=cache, eval=bestModels}
best_models(data)
```


#### Error Rate 

##### Descriptive

```{r message=FALSE, warning=FALSE, cache=cache}
plot_descriptive_err(data, side = "updown")
```

##### Model Specification

```{r m_err_poggendorff, message=FALSE, warning=FALSE, eval=runModels}
formula <- brms::bf(
  Error ~ Illusion_Effect / (cbrtmod(Illusion_Difference) * sqrt(abs(Illusion_Strength))) +
    (1 + Illusion_Effect / (cbrtmod(Illusion_Difference) * sqrt(abs(Illusion_Strength))) | Participant),
  family = "bernoulli"
)

# brms::get_prior(formula, data = data)
# brms::validate_prior(formula)

model_poggendorff_err <- brms::brm(formula,
  data = data,
  refresh = 100
)

# parameters::parameters(model_poggendorff_err)

save(model_poggendorff_err, file="models/model_poggendorff_err.Rdata")
```
```{r message=FALSE, warning=FALSE, cache=cache}
load("models/model_poggendorff_err.RData")
load("models/gam_poggendorff_err.RData")
```

##### Model Visualization


```{r message=FALSE, warning=FALSE, cache=cache}
p_poggendorff_err <- plot_model_err(data, model_poggendorff_err, gam_poggendorff_err)
p_poggendorff_err
```


#### Reaction Time

##### Descriptive

```{r message=FALSE, warning=FALSE, cache=cache}
data <- filter(df, Illusion_Type == "Poggendorff", Error == 0)

plot_descriptive_rt(data, side = "updown")
```

##### Model Specification

```{r m_rt_poggendorff, message=FALSE, warning=FALSE, cache=cache, eval=FALSE}
formula <- brms::bf(
  RT ~ Illusion_Effect / (cbrtmod(Illusion_Difference) * sqrt(abs(Illusion_Strength))) +
    poly(ISI, 2) + 
    (1 + Illusion_Effect / (cbrtmod(Illusion_Difference) * sqrt(abs(Illusion_Strength))) | Participant),
  sigma ~ Illusion_Effect / (cbrtmod(Illusion_Difference) * sqrt(abs(Illusion_Strength))) + 
    poly(ISI, 2) + (1 | Participant),
  beta ~ Illusion_Effect / (cbrtmod(Illusion_Difference) * sqrt(abs(Illusion_Strength))) + 
    poly(ISI, 2) + (1 | Participant),
  family = "exgaussian"
)


model_poggendorff_rt <- brms::brm(formula,
  data = data,
  refresh = 100,
  init = 0
)

save(model_ponzo_rt, file="models/model_poggendorff_rt.Rdata")
```
```{r message=FALSE, warning=FALSE, cache=cache, eval=FALSE}
load("models/model_poggendorff_rt.RData")
load("models/gam_poggendorff_rt.RData")

plot_ppcheck(model_poggendorff_rt)
# performance::check_model(model_poggendorff_rt)
# parameters::parameters(model)
```

##### Model Visualization


```{r message=FALSE, warning=FALSE, cache=cache, eval=FALSE}
p_poggendorff_rt <- plot_model_rt(data, model_poggendorff_rt, gam_poggendorff_rt)
p_poggendorff_rt
```



### Contrast

#### Model Selection


```{r message=FALSE, warning=FALSE, cache=cache}
data <- filter(df, Illusion_Type == "Contrast")
```

```{r message=FALSE, warning=FALSE, cache=cache, eval=bestModels}
best_models(data)
```


#### Error Rate 

##### Descriptive

```{r message=FALSE, warning=FALSE, cache=cache}
data <- filter(df, Illusion_Type == "Contrast")

plot_descriptive_err(data, side = "updown")
```


##### Model Specification

```{r m_err_contrast, message=FALSE, warning=FALSE, eval=runModels}
formula <- brms::bf(
  Error ~ Illusion_Effect / (sqrt(Illusion_Difference) * sqrt(abs(Illusion_Strength))) +
    (1 + Illusion_Effect / (sqrt(Illusion_Difference) * sqrt(abs(Illusion_Strength))) | Participant),
  family = "bernoulli"
)

# brms::get_prior(formula, data = data)
# brms::validate_prior(formula)

model_contrast_err <- brms::brm(formula,
  data = data,
  refresh = 50
)

# parameters::parameters(model_contrast_err)

save(model_contrast_err, file="models/model_contrast_err.Rdata")
```
```{r message=FALSE, warning=FALSE, cache=cache}
load("models/model_contrast_err.RData")
load("models/gam_contrast_err.RData")
```

##### Model Visualization


```{r message=FALSE, warning=FALSE, cache=cache}
p_contrast_err <- plot_model_err(data, model_contrast_err, gam_contrast_err)
p_contrast_err
```



#### Reaction Time

##### Descriptive

```{r message=FALSE, warning=FALSE, cache=cache}
data <- filter(df, Illusion_Type == "Contrast", Error == 0)

plot_descriptive_rt(data, side = "updown")
```

##### Model Specification

```{r m_rt_contrast, message=FALSE, warning=FALSE, cache=cache, eval=FALSE}
formula <- brms::bf(
  RT ~ Illusion_Effect / (sqrt(Illusion_Difference) * sqrt(abs(Illusion_Strength))) +
    poly(ISI, 2) + 
    (1 + Illusion_Effect / (sqrt(Illusion_Difference) * sqrt(abs(Illusion_Strength))) | Participant),
  sigma ~ Illusion_Effect / (sqrt(Illusion_Difference) * sqrt(abs(Illusion_Strength))) + 
    poly(ISI, 2) + (1 | Participant),
  beta ~ Illusion_Effect / (sqrt(Illusion_Difference) * sqrt(abs(Illusion_Strength))) + 
    poly(ISI, 2) + (1 | Participant),
  family = "exgaussian"
)


model_contrast_rt <- brms::brm(formula,
  data = data,
  refresh = 50,
  init = 0
)

save(model_contrast_rt, file="models/model_contrast_rt.Rdata")
```
```{r message=FALSE, warning=FALSE, cache=cache, eval=FALSE}
load("models/model_contrast_rt.RData")
load("models/gam_contrast_rt.RData")

plot_ppcheck(model_contrast_rt)
# performance::check_model(model_contrast_rt)
# parameters::parameters(model)
```

##### Model Visualization


```{r message=FALSE, warning=FALSE, cache=cache, eval=FALSE}
p_contrast_rt <- plot_model_rt(data, model_contrast_rt, gam_contrast_rt)
p_contrast_rt
```



## Individual Scores

### Model-based Descriptors

```{r message=FALSE, warning=FALSE, cache=cache, eval=FALSE}
data <- rbind(
  extract_random(model_delboeuf_err, "Delboeuf"),
  # extract_random(model_delboeuf_rt, "Delboeuf"),
  extract_random(model_ebbinghaus_err, "Ebbinghaus"),
  # extract_random(model_ebbinghaus_rt, "Ebbinghaus"),
  extract_random(model_rodframe_err, "Rod-Frame"),
  # extract_random(model_rodframe_rt, "Rod-Frame"),
  extract_random(model_verticalhorizontal_err, "Vertical-Horizontal"),
  # extract_random(model_verticalhorizontal_rt, "Vertical-Horizontal"),
  extract_random(model_zollner_err, "Zöllner"),
  # extract_random(model_zollner_rt, "Zöllner"),
  extract_random(model_white_err, "White"),
  # extract_random(model_white_rt, "White"),
  extract_random(model_mullerlyer_err, "Müller-Lyer"),
  # extract_random(model_mullerlyer_rt, "Müller-Lyer"),
  extract_random(model_ponzo_err, "Ponzo"),
  # extract_random(model_ponzo_rt, "Ponzo"),
  extract_random(model_poggendorff_err, "Poggendorff"),
  # extract_random(model_poggendorff_rt, "Poggendorff"),
  extract_random(model_contrast_err, "Contrast")
  # extract_random(model_contrast_rt, "Contrast")
) |> 
  filter(
    !str_detect(Parameter, "Intercept_"),
    !str_detect(Parameter, "Cong"),
    !str_detect(Parameter, "Cong_Prob"),
    !str_detect(Parameter, "Null_"),
    !str_detect(Parameter, "Diff_"))
# unique(data$Parameter)

# data |>
#   # group_by(Illusion_Type, Parameter) |> 
#   # standardize(select="Value") |> 
#   # ungroup() |> 
#   # mutate(order = mean(Value)) |> 
#   # ungroup() |> 
#   # mutate(Participant = fct_reorder(Participant, order)) |> 
#   ggplot(aes(y = Participant, x = Value)) +
#   # ggdist::stat_slabinterval(aes(fill = Illusion_Type, color=Illusion_Type), alpha=0.5) +
#   ggdist::stat_pointinterval(aes(fill = Illusion_Type, color=Illusion_Type), alpha=0.5) +
#   # coord_cartesian(xlim=c(-4, 4)) +
#   facet_wrap(~Parameter, scales = "free_x") +
#   theme(axis.text.y = element_blank())



# df[df$Illusion_Type == "Poggendorff" & df$Participant == "5cbb77bf418c540001641e67_sp53j", ]

random <- data |>
  mutate(Parameter = paste0(Illusion_Type, "_", Parameter),
         Parameter = clean_illusionName(Parameter)) |>
  group_by(Participant, Parameter) |>
  summarize(Score = median(Value, na.rm = TRUE), .groups = "drop") |>
  ungroup() |>
  group_by(Parameter) |>
  mutate(Score = Score / sd(Score, na.rm = TRUE)) |>  # Scale
  ungroup()  |>
  pivot_wider(names_from = Parameter, values_from = Score)

# plot(estimate_density(select(random, -Participant)))
```




<!-- ### Approximation -->

<!-- ```{r message=FALSE, warning=FALSE, cache=cache} -->
<!-- individual <- data.frame() -->
<!-- for (participant in unique(dfsub$Participant)) { -->
<!--   cat(".") -->
<!--   dat <- data.frame() -->

<!--   dat <- glm(Error ~ sqrtmod(Illusion_Difference) * sqrtmod(Illusion_Strength), -->
<!--     family = "binomial", -->
<!--     data = filter( -->
<!--       df,  -->
<!--       Participant == participant, -->
<!--       Illusion_Type == "Delboeuf" -->
<!--     ) -->
<!--   ) |>  -->
<!--     parameters::parameters() |>  -->
<!--     mutate(Parameter = paste0("Delboeuf_Individual_", Parameter)) |>  -->
<!--     rbind(dat) -->

<!--   dat <- glm(Error ~ sqrt(Illusion_Difference) * logmod(Illusion_Strength), -->
<!--     family = "binomial", -->
<!--     data = filter( -->
<!--       df,  -->
<!--       Participant == participant, -->
<!--       Illusion_Type == "Ebbinghaus" -->
<!--     ) -->
<!--   ) |>  -->
<!--     parameters::parameters() |>  -->
<!--     mutate(Parameter = paste0("Ebbinghaus_Individual_", Parameter)) |>  -->
<!--     rbind(dat) -->


<!--   individual <- dat |> -->
<!--     select(Parameter, Coefficient) |>  -->
<!--     as.data.frame() |> -->
<!--     mutate( -->
<!--       Participant = participant, -->
<!--       Parameter = clean_parameterName(Parameter) -->
<!--     ) |>  -->
<!--     rbind(individual) -->
<!-- } -->

<!-- individual <- individual |>  -->
<!--   pivot_wider(names_from = c("Parameter"), values_from = c("Coefficient")) |>  -->
<!--   arrange(Participant) -->
<!-- ``` -->






```{r message=FALSE, warning=FALSE, cache=cache, eval=FALSE}
# Correlation
r <- data.frame()
for(ill in c("Delboeuf", 
             "Ebbinghaus")) {
  r <- correlation::correlation(
    # data = random |> 
    #   arrange(Participant) |> 
    #   data_select(select=ill, regex=TRUE),
    data = empirical |> 
      data_select(select=ill, regex=TRUE),
    data2 = individual |>
      data_select(select=ill, regex=TRUE),
    p_adjust="none"
    ) |> 
    mutate(Illusion_Type = ill,
           Parameter1 = prettify_parameterName(Parameter1),
           Parameter2 = prettify_parameterName(Parameter2)) |> 
    select(Illusion_Type, Parameter1, Parameter2, r, p) |> 
    rbind(r)
}

r |>
  mutate(label = insight::format_p(p, stars_only=TRUE)) |> 
  ggplot(aes(x = Parameter2, y = Parameter1)) +
  geom_tile(aes(fill = r)) +
  geom_text(aes(label=label)) +
  scale_alpha_continuous(range = c(1, 0.5)) +
  scale_fill_gradient2(low = "#2196F3", mid = "white", high = "#F44336", midpoint = 0, limit = c(-1, 1), space = "Lab", name = "Correlation", guide = "legend") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust=1)) +
  facet_wrap(~Illusion_Type, scales = "free")
```


## Structure

### Correlation 

```{r message=FALSE, warning=FALSE, cache=cache, eval=FALSE}
cor <- correlation::correlation(random, redundant = TRUE)

p_data <- cor |>
  mutate(
    Parameter1 = prettify_parameterName(Parameter1),
    Parameter2 = prettify_parameterName(Parameter2)
  ) |>
  correlation::cor_sort(hclust_method = "ward.D2") |>
  cor_lower() |>
  mutate(
    Text = insight::format_value(r, zap_small = TRUE, digits = 3),
    Text = str_replace(str_remove(Text, "^0+"), "^-0+", "-"),
    Parameter2 = fct_rev(Parameter2)
  )


p_data |>
  ggplot(aes(x = Parameter2, y = Parameter1)) +
  geom_tile(aes(fill = r)) +
  # geom_text(aes(label = Text), size = 2) +
  scale_fill_gradient2(low = "#2196F3", mid = "white", high = "#F44336", midpoint = 0, limit = c(-1, 1), space = "Lab", name = "Correlation", guide = "legend") +
  scale_x_discrete(expand = c(0, 0)) +
  scale_y_discrete(expand = c(0, 0)) +
  labs(title = "Correlation Matrix", x = NULL, y = NULL) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 90, hjust = 1),
    plot.title = element_text(hjust = 0.5, face = "bold"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  )
```

### Factor Analysis

#### First Level

```{r message=FALSE, warning=FALSE, cache=cache, eval=FALSE}
data <- select(random, -Participant)

rez <- parameters::n_factors(data, n_max=15)
plot(rez)


fa <- parameters::factor_analysis(data,
  cor = as.matrix(cor),
  n = 9,
  rotation = "oblimin",
  fm = "mle",
  sort = TRUE
)


print(tibble::as_tibble(fa), n=30)
plot(fa)
# psych::omega(data, fm = "mle", nfactors=9)
# fa <- psych::fa.multi(as.matrix(cor), nfactors = 3, nfact2 = 1, n.obs = nrow(random))
# psych::fa.multi.diagram(fa)
```

#### Second Level

```{r message=FALSE, warning=FALSE, cache=cache, eval=FALSE}
data <- predict(fa)

rez <- parameters::n_factors(data, rotation = "oblimin")
plot(rez)

fa2 <- parameters::factor_analysis(data,
  n = 1,
  rotation = "varimax",
  fm = "mle",
  sort = TRUE
)

# psych::schmid(attributes(fa)$model, nfactors = 1)
```


#### Visualization
```{r message=FALSE, warning=FALSE, cache=cache, eval=FALSE}
library(ggraph)

dat <- rbind(
  attributes(fa)$loadings_long,
  attributes(fa2)$loadings_long |>
    mutate(Component = str_replace(Component, "ML", "G"))
) |>
  tidygraph::as_tbl_graph() |>
  tidygraph::activate("nodes")


# Get order of indices
# idx <- correlation::cor_sort(cor, hclust_method = "ward.D2") |>
#   summary() |>
#   pull(Parameter)
# idx <- sort(fa$Variable)
idx <- fa$Variable

get_x <- function(name, x) {
  case_when(
    name == "G1" ~ 0.5,
    # name == "G1" ~ 0/3,
    # name == "G2" ~ 1/3,
    # name == "G3" ~ 2/3,
    # name == "G4" ~ 3/3,
    name == "ML1" ~ 0/(ncol(fa)-3),
    name == "ML2" ~ 1/(ncol(fa)-3),
    name == "ML3" ~ 2/(ncol(fa)-3),
    name == "ML4" ~ 3/(ncol(fa)-3),
    name == "ML5" ~ 4/(ncol(fa)-3),
    name == "ML6" ~ 5/(ncol(fa)-3),
    name == "ML7" ~ 6/(ncol(fa)-3),
    name == "ML8" ~ 7/(ncol(fa)-3),
    name == "ML9" ~ 8/(ncol(fa)-3),
    name == "ML10" ~ 9/(ncol(fa)-3),
    name == "ML11" ~ 10/(ncol(fa)-3),
    name == "ML12" ~ 11/(ncol(fa)-3),
    TRUE ~ x)
}

dat |>
  mutate(
    x = sapply(as.data.frame(dat)$name, function(x) {
      if (x %in% idx) {
        (which(idx == x) - 1) / (length(idx) - 1)
      } else {
        NA
      }
    })
  ) |>
  mutate(
    x = get_x(name, x),
    y = case_when(
    str_detect(name, "G") ~ 2,
    str_detect(name, "ML") ~ 1,
    TRUE ~ 0),
    angle = ifelse(name %in% idx, 90, 0),
    hjust = ifelse(name %in% idx, 1.01, 0),
    name = prettify_parameterName(name),
    Illusion_Type = str_split_fixed(name, " - ", n=2)[, 1]) |> 
  tidygraph::activate("edges") |> 
  filter(abs(Loading) > 0.2) |> 
  ggraph(layout = "nicely") +
  geom_edge_link(aes(edge_width = Loading, edge_colour = as.factor(sign(Loading)))) +
  geom_node_point(aes(color = Illusion_Type), size=3) +
  geom_node_text(aes(label = name, angle = angle, hjust=hjust)) +
  scale_y_continuous(expand = expansion(c(.6, .1))) +
  scale_edge_width_continuous(range=c(0.1, 1)) +
  scale_edge_color_manual(values=c("#F44336", "#2196F3")) +
  scale_color_manual(values=c("Delboeuf" = "#F44336", Ebbinghaus = "#E91E63",
                              "Rod-Frame" = "#9C27B0")) +
  guides(edge_colour = "none") +
  ggraph::theme_graph()
```

### SEM

```{r message=FALSE, warning=FALSE, cache=cache, eval=FALSE}
library(lavaan)
library(tidySEM)
library(ggraph)


names <- names(select(random, -Participant))
data <- setNames(as.data.frame(str_split_fixed(names, "_", 3)), c("Illusion_Type", "Parameter", "Model"))
data$Name <- names

# Model 1 - by Illusion
lvl1 <- paste(data$Illusion_Type, "=~", data$Name)
lvl2 <- paste("I =~", unique(data$Illusion_Type))
resid <- as.data.frame(t(utils::combn(x=unique(data$Illusion_Type), 2)))
resid <- paste(resid$V1, "~~", resid$V2)

m1 <- sem(model = paste0(c(lvl1, lvl2), collapse = "\n"),
          data  = random,
          estimator = "ML",
          missing = "ml",
          bounds = TRUE)  # robust.two.stage


# Model 2 - by Parameter
lvl1 <- paste(data$Parameter, "=~", data$Name)
lvl2 <- paste("I =~", unique(data$Parameter))
resid <- as.data.frame(t(utils::combn(x=unique(data$Parameter), 2)))
resid <- paste(resid$V1, "~~", resid$V2)

m2 <- sem(model = paste0(c(lvl1, lvl2), collapse = "\n"),
          data  = random)

# # Model 3
# lvl1 <- paste(data$Model, "=~", data$Name)
# lvl2 <- paste("G =~", unique(data$Model))
# 
# m2 <- sem(model = paste0(c(lvl1, lvl2), collapse = "\n"),
#            data  = random)



anova(m1, m2)

summary(m1, standardize = TRUE)
```

```{r message=FALSE, warning=FALSE, cache=cache, eval=FALSE}
# https://cjvanlissa.github.io/tidySEM/articles/sem_graph.html
edges <- tidySEM::get_edges(m1) |> 
  mutate(color = ifelse(sign(as.numeric(est)) >= 0, "1", "-1"),
         width = abs(as.numeric(est))) |> 
  filter(lhs != rhs)

nodes <- tidySEM::get_nodes(m1) |> 
  mutate(label = prettify_parameterName(name),
         angle = ifelse(grepl("_", name), 90, 0),
         hjust = ifelse(grepl("_", name), 1.01, 0))

tidygraph::tbl_graph(nodes = nodes,
                     edges = edges) |> 
  ggraph(layout = "sugiyama") +
  geom_edge_link(aes(edge_width = width, 
                             color = color,
                             label=est_sig_std), angle_calc="along", label_dodge=unit(-0.015, "npc")) +
  geom_node_point() +
  geom_node_text(aes(label = label, angle = angle, hjust=hjust)) +
  scale_edge_color_manual(values=c("#F44336", "#2196F3"))  +
  scale_y_continuous(expand = expansion(c(.6, .1))) +
  scale_edge_width_continuous(range=c(0.1, 1.5)) +
  guides(edge_colour = "none", edge_width = "none") +
  theme_graph() 

dfsem <- mutate(as.data.frame(predict(m1)), Participant = random$Participant)
```

```{r message=FALSE, warning=FALSE, cache=cache, eval=FALSE}
r <- correlation(arrange(dfsem, Participant), arrange(empirical, Participant), sort=TRUE, p_adjust="none")

r |>
  mutate(label = insight::format_p(p, stars_only=TRUE)) |> 
  ggplot(aes(x = Parameter1, y = Parameter2)) +
  geom_tile(aes(fill = r)) +
  geom_text(aes(label=label)) +
  scale_alpha_continuous(range = c(1, 0.5)) +
  scale_fill_gradient2(low = "#2196F3", mid = "white", high = "#F44336", midpoint = 0, limit = c(-1, 1), space = "Lab", name = "Correlation", guide = "legend") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust=1))
```





### Empirical Descriptors


We have to keep in mind that individual scores are the result of several layers of simplification: 1) the individual coefficient is that of simpler models that sometimes do not perfectly capture the underlying dynamics (especially in the case of ...), 2) the structural equation model from which they are obtained is also constructed on layers of abstractions. Thus, we wanted to test wether these indices relate to some simple empirical scores, such as the average error rate and RT in the task.

```{r message=FALSE, warning=FALSE, cache=cache, eval=FALSE}
# Average for 4 higher level of task difficulty
empirical <- df |>
  filter(Illusion_Effect == "Incongruent") |> 
  group_by(Participant, Illusion_Type, Illusion_Strength) |>
  arrange(Illusion_Difference) |> 
  slice(0:4) |> 
  # select(Illusion_Strength, Illusion_Difference)
  group_by(Participant, Illusion_Type) |>
  summarize(
    TaskHard_Error = sum(Error, na.rm=TRUE) / n(),
    TaskHard_RTMean = mean(ifelse(Error == 0, RT, NA), na.rm=TRUE)
    # Illu_RTSpread = sd(ifelse(Error == 0, RT, NA), na.rm=TRUE),
  ) |>
  ungroup() |> 
  mutate(Illusion_Type = clean_illusionName(Illusion_Type))  |> 
  pivot_wider(names_from = c("Illusion_Type"), values_from = c("TaskHard_Error", "TaskHard_RTMean"), names_glue = "{Illusion_Type}_{.value}") 

# Average for 4 higher level of illusion strength
empirical <- df |>
  filter(Illusion_Effect == "Incongruent") |> 
  group_by(Participant, Illusion_Type, Illusion_Difference) |>
  arrange(desc(Illusion_Strength)) |> 
  slice(0:4) |> 
  # select(Illusion_Strength, Illusion_Difference)
  group_by(Participant, Illusion_Type) |>
  summarize(
    IlluStrong_Error = sum(Error, na.rm=TRUE) / n(),
    IlluStrong_RTMean = mean(ifelse(Error == 0, RT, NA), na.rm=TRUE)
    # Diff_RTSpread = sd(ifelse(Error == 0, RT, NA), na.rm=TRUE),
  ) |>
  ungroup() |> 
  mutate(Illusion_Type = clean_illusionName(Illusion_Type))  |> 
  pivot_wider(names_from = c("Illusion_Type"), values_from = c("IlluStrong_Error", "IlluStrong_RTMean"), names_glue = "{Illusion_Type}_{.value}") |> 
  full_join(empirical, by = "Participant") 
```


<!-- ```{r message=FALSE, warning=FALSE, cache=cache, eval=FALSE} -->
<!-- rez <- parameters::n_factors(select(empirical, -Participant), n_max=30) -->
<!-- plot(rez) -->

<!-- r <- correlation::correlation(empirical, p_adjust = "none", sort=TRUE) -->


<!-- r |> -->
<!--   ggplot(aes(x = Parameter2, y = Parameter1)) + -->
<!--   geom_tile(aes(fill = r)) + -->
<!--   # geom_text(aes(label = Text), size = 2) + -->
<!--   scale_fill_gradient2(low = "#2196F3", mid = "white", high = "#F44336", midpoint = 0, limit = c(-1, 1), space = "Lab", name = "Correlation", guide = "legend") + -->
<!--   scale_x_discrete(expand = c(0, 0)) + -->
<!--   scale_y_discrete(expand = c(0, 0)) + -->
<!--   labs(title = "Correlation Matrix", x = NULL, y = NULL) + -->
<!--   theme_minimal() + -->
<!--   theme( -->
<!--     axis.text.x = element_text(angle = 90, hjust = 1), -->
<!--     plot.title = element_text(hjust = 0.5, face = "bold"), -->
<!--     panel.grid.major = element_blank(), -->
<!--     panel.grid.minor = element_blank() -->
<!--   ) -->

<!-- fa <- parameters::factor_analysis(select(empirical, -Participant), -->
<!--   n = 13, -->
<!--   rotation = "oblimin", -->
<!--   fm = "mle", -->
<!--   sort = TRUE -->
<!-- ) -->


<!-- print(tibble::as_tibble(fa), n=30) -->
<!-- plot(fa) -->
<!-- ``` -->



```{r message=FALSE, warning=FALSE, cache=cache, eval=FALSE}
# Correlation
r <- data.frame()
for(ill in c("Delboeuf", 
             "Ebbinghaus",
             "RodFrame",
             "VerticalHorizontal",
             "Zollner",
             "White",
             "MullerLyer",
             "Ponzo",
             "Poggendorff",
             "Contrast"
             )) {
  r <- correlation::correlation(
    data = random |> 
      arrange(Participant) |> 
      data_select(select=ill, regex=TRUE),
    data2 = empirical |>
      data_select(select=ill, regex=TRUE),
    p_adjust="none"
    ) |> 
    mutate(Illusion_Type = ill,
           Parameter1 = prettify_parameterName(Parameter1),
           Parameter2 = prettify_parameterName(Parameter2)) |> 
    select(Illusion_Type, Parameter1, Parameter2, r, p) |> 
    rbind(r)
}

r |>
  mutate(label = insight::format_p(p, stars_only=TRUE)) |> 
  ggplot(aes(x = Parameter2, y = Parameter1)) +
  geom_tile(aes(fill = r)) +
  geom_text(aes(label=label)) +
  scale_alpha_continuous(range = c(1, 0.5)) +
  scale_fill_gradient2(low = "#2196F3", mid = "white", high = "#F44336", midpoint = 0, limit = c(-1, 1), space = "Lab", name = "Correlation", guide = "legend") +
  # facet_wrap(~Illusion_Type, scales = "free") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust=1))
```



```{r message=FALSE, warning=FALSE, cache=cache, eval=FALSE}
# Save
dfsub |> 
  merge(dfsem, by = "Participant") |> 
  merge(empirical, by = "Participant") |> 
  write.csv("../data/study3.csv", row.names = FALSE)
```

