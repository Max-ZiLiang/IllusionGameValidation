---
title: "Illusion Game Validation (Study 2)"
output: html_document
date: "`r Sys.Date()`"
editor_options: 
  chunk_output_type: console
---

```{r, echo = FALSE, warning=FALSE, message=FALSE}
options(
  digits = 3,
  mc.cores = 4,
  brms.algorithm = "meanfield",
  brms.backend = "cmdstanr"
)

cache <- FALSE
runModels <- FALSE
fig.width <- see::golden_ratio(7)
fig.height <- 7

knitr::opts_chunk$set(
  collapse = TRUE,
  dpi = 450,
  fig.path = "./figures/",
  fig.width = fig.width,
  fig.height = fig.height
)
```


# Introduction


The goal of study 2 was to...

# Methods


```{r eval=FALSE, message=FALSE, warning=FALSE, include=FALSE}
# PREPROCESSING ================================================================
source("preprocessing.R")

# This is a local folder containing raw data from unzipped pavlovia
# It has been added to .gitignore to NOT be published on github
# (it contains the subject ID of the participants)
participants <- list.files("data/")

df <- data.frame()
for (ppt in participants) {
  df <- rbind(df, preprocess_raw(file = paste0("data/", ppt)))
}

df$Pyllusion <- "1.2"

# Fix
df[df$Illusion_Type == "Rod-Frame" & df$Date == "05/08/2022", "Illusion_Strength"] <- -1 * (df[df$Illusion_Type == "Rod-Frame" & df$Date == "05/08/2022", "Illusion_Strength"])
df[df$Illusion_Type == "Ebbinghaus", "Illusion_Difference"] <- round(df[df$Illusion_Type == "Ebbinghaus", "Illusion_Difference"], 5)


# Transformation
df$Illusion_Difference_log <- log(1 + df$Illusion_Difference)
df$Illusion_Difference_sqrt <- sqrt(df$Illusion_Difference)
df$Illusion_Difference_cbrt <- round(df$Illusion_Difference**(1 / 3), 4)
df$Illusion_Strength_log <- sign(df$Illusion_Strength) * log(1 + abs(df$Illusion_Strength))
df$Illusion_Strength_sqrt <- sign(df$Illusion_Strength) * sqrt(abs(df$Illusion_Strength))
df$Illusion_Strength_cbrt <- sign(df$Illusion_Strength) * (abs(df$Illusion_Strength)**(1 / 3))

# Save anonymized data
write.csv(df, "../data/study2.csv", row.names = FALSE)
```


```{r message=FALSE, warning=FALSE}
library(tidyverse)
library(ggdist)
library(ggside)
library(easystats)
library(patchwork)
library(brms)
source("functions.R")

df <- read.csv("../data/study2.csv") |>
  mutate(
    Date = as.Date(Date),
    Participant = fct_reorder(Participant, Date),
    Screen_Refresh = as.character(Screen_Refresh),
    Illusion_Side = as.factor(Illusion_Side),
    Illusion_Effect = fct_relevel(as.factor(Illusion_Effect), "Incongruent", "Congruent"),
    Block = as.factor(Block),
    Education = fct_relevel(Education, "Doctorate", "Master", "Bachelor", "High School", "Other")
  )
```


## Exclusions {.tabset}

```{r message=FALSE, warning=FALSE}
# plot(estimate_density(dfraw[dfraw$Participant == "60684f29dbfe1bb2059e5e27_rkqoy", "RT"]))

# Dear participant, thank you for participating in our study. Unfortunately, we didn't receive your data :( did something happen? Some technical issue? We would like to kindly ask you to return your participation so that we can open up more slots. Thank you in advance, and apologies for the inconvenience! 

# Dear participant, thank you for participating in our study. Unfortunately, our system detected multiple issues in your data (such as implausibly short responses, and random-like pattern of answers), which makes it unusable. We understand that you might have been in a hurry or had some other issues; we hope to open-up more slots in the future would you be interested to participate again.

# Dear participant, thank you for participating in our study. Unfortunately, our system detected multiple issues in your data (such as implausibly short responses, and random-like pattern of answers - in particular in the 2nd part of the study), which makes it unusable. We understand that you might have been in a hurry or had some other issues, and so we kindly ask you to return your participation; we hope to open-up more slots in the future would you be interested to participate again.

# Just received the results: in your case, the three most prominent issues were your response pattern that was equivalent to random (in the sequence of keystrokes) that led to a chance-level performance (that was also significantly different from the rest of the population). Moreover, your reaction time distribution was also very different from the norm, with a vast majority of implausibly short responses (i.e., that are faster than the time it takes the brain to process a visual input). This issue was even more prominent in the second block (after the break), which typically happens when participants are in a rush to finish. Finally, your overall completion time was also significantly below the average. Again, we apologize, we understand that your time is valuable, but unfortunately we run too on limited funds and can hardly spare more on unusable data. Sorry for the inconvenience, we will try to open-up more slots soon.

outliers <- c(
  # Error rate of 48.8% Very short RT
  # Prolific Status: REJECTED (06/08)
  "5e66ed53de7896486f9a71f8_p8ckk",
  # 2nd block of responses very fast
  # Prolific Status: RETURN REQUESTED (07/08)
  "61443e47c248a375c899a0cf_9qz3u"
)

partial_outliers <- c(
  # 2nd block a bit bad
  "5c43cd414fe4f800016e4983_0zp37", 
  # Entire 2nd block bad
  "61564e378e974bdbe42763a2_hhufm")
```

We removed `r length(outliers)` participants upon inspection of the average error rage (when close to 50%, suggesting random answers) and/or when the reaction time distribution was implausibly fast. 

For each block, we computed the error rate and, if more than 50%, we discarded the whole block (as it likely indicates that instructions got mixed up, for instance participants were selecting the smaller instead of the bigger circle).

### Error Rate

```{r message=FALSE, warning=FALSE}
dfsub <- df |>
  group_by(Participant) |>
  summarize(
    # n = n(),
    Error = sum(Error) / n(),
    RT_Mean = mean(RT),
    RT_SD = sd(RT),
    IPIP6_SD = mean(IPIP6_SD),
    PID5_SD = mean(PID5_SD),
  ) |>
  ungroup() |>
  arrange(desc(Error))

data.frame(Participant = c("Total"), t(sapply(dfsub[2:ncol(dfsub)], mean, na.rm=TRUE))) |> 
  rbind(dfsub) |> 
  knitr::kable() |>
  kableExtra::row_spec(1, italic = TRUE) |> 
  kableExtra::row_spec(which(dfsub$Participant %in% outliers) + 1, background = "#EF9A9A") |> 
  kableExtra::row_spec(which(dfsub$Participant %in% partial_outliers) + 1, background = "#FFECB3")
```


### Reaction Time Distribution


```{r message=FALSE, warning=FALSE, fig.width=20, fig.height=20}
# RT distribution
p <- df |> 
  filter(RT < 10000) |> 
  estimate_density(select = "RT", at = c("Participant", "Block")) |>
  group_by(Participant) |>
  normalize(select = "y") |>
  ungroup() |>
  mutate(color = ifelse(Participant %in% outliers, "red", ifelse(Participant %in% partial_outliers, "orange", "blue"))) |>
  ggplot(aes(x = x, y = y)) +
  geom_area(data = normalize(estimate_density(filter(df, RT < 10000), select = "RT"), select = "y"), alpha = 0.2) +
  geom_line(aes(color = color, group = interaction(Participant, Block), linetype = Block)) +
  geom_vline(xintercept = 125, linetype = "dashed", color = "red") +
  scale_color_manual(values = c("red" = "#F44336", "orange" = "#FF9800", "blue" = "blue"), guide = "none") +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  coord_cartesian(xlim = c(0, 3000)) +
  theme_modern() +
  theme(axis.text.y = element_blank()) +
  facet_wrap(~Participant) +
  labs(y = "", x = "Reaction Time (ms)")
# p
# ggsave("figures/outliers.png", p, width=20, height=15)

# Filter out
df <- filter(df, !Participant %in% outliers)
```


### Error Rate per Illusion Block

```{r message=FALSE, warning=FALSE}
temp <- df |>
  group_by(Participant, Illusion_Type, Block) |>
  summarize(ErrorRate_per_block = sum(Error) / n()) |>
  ungroup() |>
  arrange(desc(ErrorRate_per_block))

temp2 <- temp |>
  filter(ErrorRate_per_block >= 0.5) |>
  group_by(Illusion_Type, Block) |>
  summarize(n = n()) |>
  arrange(desc(n), Illusion_Type) |>
  ungroup() |>
  mutate(
    n_trials = cumsum(n * 56),
    p_trials = n_trials / nrow(df)
  )

# knitr::kable(temp2)

p1 <- temp |>
  estimate_density(at = c("Illusion_Type", "Block")) |>
  ggplot(aes(x = x, y = y)) +
  geom_line(aes(color = Illusion_Type, linetype = Block)) +
  geom_vline(xintercept = 0.5, linetype = "dashed") +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  labs(y = "Distribution", x = "Error Rate") +
  theme_modern()

p2 <- temp2 |>
  mutate(Block = fct_rev(Block)) |>
  ggplot(aes(x = Illusion_Type, y = p_trials)) +
  geom_bar(stat = "identity", aes(fill = Block)) +
  scale_x_discrete(expand = c(0, 0)) +
  scale_y_continuous(labels = scales::percent, expand = c(0, 0)) +
  labs(y = "Percentage of Trials Removed", x = "Illusion Type") +
  theme_modern() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

p1 | p2


# Drop
df <- df |>
  group_by(Participant, Illusion_Type, Block) |>
  mutate(ErrorRate_per_block = sum(Error) / n()) |>
  ungroup() |>
  filter(ErrorRate_per_block < 0.5) |>
  select(-ErrorRate_per_block)

# Drop also participant with bad second block
df <- filter(
  df,
  !(Participant %in% partial_outliers & df$Block == 2))

rm(temp, temp2)
```


### Reaction Time per Trial

```{r message=FALSE, warning=FALSE}
df <- df |>
  group_by(Participant, Error) |>
  mutate(Outlier = ifelse(Error == 0 & (RT < 125 | standardize(RT) > 4), TRUE, FALSE)) |>
  ungroup()

p1 <- estimate_density(df, select = "RT", at = "Participant") |>
  group_by(Participant) |>
  normalize(select = "y") |>
  ungroup() |>
  merge(df |>
    filter(Error == 0) |>
    group_by(Participant) |>
    summarize(Outlier = mean(RT) + 4 * sd(RT))) |>
  mutate(Outlier = ifelse(x >= Outlier, TRUE, FALSE)) |>
  ggplot(aes(x = x, y = y)) +
  geom_area(data = normalize(estimate_density(df, select = "RT"), select = "y"), alpha = 0.2) +
  geom_line(aes(color = Participant, linetype = Outlier)) +
  geom_vline(xintercept = c(125), linetype = "dashed", color = "red") +
  scale_color_material_d("rainbow", guide = "none") +
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0)) +
  guides(linetype = "none") +
  coord_cartesian(xlim = c(0, 4000)) +
  theme_modern() +
  theme(axis.text.y = element_blank()) +
  labs(y = "", x = "Reaction Time (ms)")


p2 <- df |>
  group_by(Participant) |>
  summarize(Outlier = sum(Outlier) / n()) |>
  mutate(Participant = fct_reorder(Participant, Outlier)) |>
  ggplot(aes(x = Participant, y = Outlier)) +
  geom_bar(stat = "identity", aes(fill = Participant)) +
  scale_fill_material_d("rainbow", guide = "none") +
  scale_x_discrete(expand = c(0, 0)) +
  scale_y_continuous(expand = c(0, 0), labels = scales::percent) +
  see::theme_modern() +
  theme(axis.text.x = element_blank())

p1 | p2
```

We removed `r sum(df$Outlier)` (`r insight::format_value(sum(df$Outlier) / nrow(df), as_percent=TRUE)`) outlier trials (125 ms < RT < 4 SD above mean).

```{r message=FALSE, warning=FALSE}
df <- filter(df, Outlier == FALSE)
df$RT <- df$RT / 1000  # Convert to second for better model convergence
```




## Participants



```{r message=FALSE, warning=FALSE}
dfsub <- df |>
  group_by(Participant) |>
  select(Participant, Age, Sex, Education, Nationality, Ethnicity, Duration, Break_Duration, Screen_Resolution, Screen_Refresh, Device_OS, starts_with("IPIP6"), starts_with("PID5")) |>
  slice(1) |>
  ungroup()
```

The final sample included `r report::report_participants(dfsub, age="Age", sex="Sex")`.

```{r }
plot_distribution <- function(dfsub, what = "Age", title = what, subtitle = "", fill = "orange") {
  dfsub |>
    ggplot(aes_string(x = what)) +
    geom_density(fill = fill) +
    geom_vline(xintercept = mean(dfsub[[what]]), color = "red", linetype = "dashed") +
    scale_x_continuous(expand = c(0, 0)) +
    scale_y_continuous(expand = c(0, 0)) +
    ggtitle(title, subtitle = subtitle) +
    theme_modern() +
    theme(
      plot.title = element_text(face = "bold", hjust = 0.5),
      plot.subtitle = element_text(face = "italic", hjust = 0.5),
      axis.title.x = element_blank(),
      axis.title.y = element_blank(),
      axis.text.y = element_blank()
    )
}

plot_waffle <- function(dfsub, what = "Nationality", title = what) {
  ggwaffle::waffle_iron(dfsub, what) |>
    # mutate(label = emojifont::fontawesome('fa-twitter')) |>
    ggplot(aes(x, y, fill = group)) +
    ggwaffle::geom_waffle() +
    # geom_point() +
    # geom_text(aes(label=label), family='fontawesome-webfont', size=4) +
    coord_equal() +
    ggtitle(title) +
    labs(fill = "") +
    theme_void() +
    theme(plot.title = element_text(face = "bold", hjust = 0.5))
}
```

```{r fig.width=20, fig.height=15}
p1 <- plot_distribution(dfsub, "Age", fill = "#FF9800")
p2 <- plot_distribution(dfsub, "Duration", title = "Total Duration", subtitle = "in minutes", fill = "#F44336")
p3 <- plot_distribution(dfsub, "Break_Duration", title = "Break Duration", subtitle = "in minutes", fill = "#3F51B5")

p4 <- plot_waffle(dfsub, "Sex") +
  scale_fill_manual(values = c("Male" = "#2196F3", "Female" = "#E91E63", "Other" = "#FF9800"))

p5 <- plot_waffle(dfsub, "Education") +
  scale_fill_viridis_d()

p6 <- plot_waffle(dfsub, "Nationality") +
  scale_fill_metro_d()

p7 <- plot_waffle(dfsub, "Ethnicity") +
  scale_fill_manual(values = c("Latino" = "#FF5722", "Asian" = "#FF9800", "Caucasian" = "#2196F3", "African" = "#4CAF50", "Jewish" = "#9C27B0"))

p8 <- plot_waffle(dfsub, "Screen_Resolution", title = "Screen Resolution") +
  scale_fill_pizza_d() +
  guides(fill = "none")

p9 <- plot_waffle(dfsub, "Device_OS", title = "Device OS") +
  scale_fill_bluebrown_d()

# p10 <- plot_waffle(dfsub, "Screen_Refresh") +
#   scale_fill_viridis_d()


(p1 / p2 / p3) | (p4 / p5 / p6) | (p7 / p8 / p9)
```




## Models {.tabset}

### Delboeuf

#### Model Selection

```{r message=FALSE, warning=FALSE, cache=cache}
data <- filter(df, Illusion_Type == "Delboeuf")
```

```{r message=FALSE, warning=FALSE, cache=cache, eval=FALSE}
best_models(data)
```


#### Error Rate 

##### Descriptive

```{r message=FALSE, warning=FALSE, cache=cache}
plot_descriptive_err(data)
```



##### Model Specification

```{r message=FALSE, warning=FALSE, cache=cache, eval=runModels}
formula <- brms::bf(
  Error ~ logmod(Illusion_Difference) * logmod(abs(Illusion_Strength)) * Illusion_Effect +
    (1 + logmod(Illusion_Difference) * logmod(abs(Illusion_Strength)) * Illusion_Effect | Participant),
  family = "bernoulli"
)

# brms::get_prior(formula, data = data)
# brms::validate_prior(formula)

model_delboeuf_err <- brms::brm(formula,
  data = data,
  refresh = 0
)

# parameters::parameters(model_delboeuf_err)

save(model_delboeuf_err, file="models/model_delboeuf_err.Rdata")
```
```{r message=FALSE, warning=FALSE, cache=cache}
load("models/model_delboeuf_err.RData")
```


##### Model Visualization


```{r message=FALSE, warning=FALSE, cache=cache}
p_delboeuf_err <- plot_model_err(data, model_delboeuf_err)
p_delboeuf_err
```



#### Reaction Time

##### Descriptive

```{r message=FALSE, warning=FALSE, cache=cache}

data <- filter(df, Illusion_Type == "Delboeuf", Error == 0)

plot_descriptive_rt(data)
```

##### Model Specification

```{r message=FALSE, warning=FALSE, cache=cache, eval=runModels}
# formula <- brms::bf(
#   RT ~ Illusion_Difference * Illusion_Strength +
#     (1 + (Illusion_Difference * Illusion_Strength) | Participant),
#   sigma ~ Illusion_Difference * Illusion_Strength +
#     (1 + (Illusion_Difference * Illusion_Strength) | Participant),
#   # ndt ~ Illusion_Difference * Illusion_Strength +
#   #   (1 | G | Participant),
#   family = "shifted_lognormal"
# )
# formula <- brms::bf(
#   RT ~ Illusion_Difference * Illusion_Strength +
#     (1 + (Illusion_Difference * Illusion_Strength) | Participant),
#   sigma ~ Illusion_Difference * Illusion_Strength +
#     (1 + (Illusion_Difference * Illusion_Strength) | Participant),
#   # beta ~ Illusion_Difference * Illusion_Strength +
#   #   (1 + (Illusion_Difference * Illusion_Strength) | Participant),
#   family = "exgaussian"
# )

formula <- brms::bf(
  RT ~ logmod(Illusion_Difference) * logmod(abs(Illusion_Strength)) * Illusion_Effect +
    (1 | Participant),
  sigma ~ 1 + (1 | Participant),
  family = "exgaussian"
)
# prior = c(
#     prior(normal(6, 1.5), class = Intercept),
#     prior(normal(0, 1), class = sigma),
#     prior(normal(0, .01), class = b, coef = c_trial)
#   )

# brms::get_prior(formula, data = data)
# brms::validate_prior(formula)

model_delboeuf_rt <- brms::brm(formula,
  data = data,
  refresh = 0
)




plot_ppcheck(model_delboeuf_rt)
# performance::check_model(model_delboeuf_rt)
# parameters::parameters(model)

save(model_delboeuf_rt, file="models/model_delboeuf_rt.Rdata")
```
```{r message=FALSE, warning=FALSE, cache=cache}
load("models/model_delboeuf_rt.RData")
```


##### Model Visualization


```{r message=FALSE, warning=FALSE, cache=cache}
p_delboeuf_rt <- plot_model_rt(data, model_delboeuf_rt)
p_delboeuf_rt
```


#### Visualization

```{r message=FALSE, warning=FALSE, cache=cache, fig.height=fig.height*2}
p_delboeuf <- plot_all(data, p_delboeuf_err, p_delboeuf_rt)
p_delboeuf
```


### Ebbinghaus

#### Model Selection

```{r message=FALSE, warning=FALSE, cache=cache}
data <- filter(df, Illusion_Type == "Ebbinghaus") 
```

```{r message=FALSE, warning=FALSE, cache=cache, eval=FALSE}
best_models(data)
```


#### Error Rate 

##### Descriptive

```{r message=FALSE, warning=FALSE, cache=cache}
plot_descriptive_err(data)
```



##### Model Specification

```{r message=FALSE, warning=FALSE, cache=cache, eval=runModels}
formula <- brms::bf(
  Error ~ sqrt(Illusion_Difference) * sqrt(abs(Illusion_Strength)) * Illusion_Effect +
    (1 + sqrt(Illusion_Difference) * sqrt(abs(Illusion_Strength)) * Illusion_Effect | Participant),
  family = "bernoulli"
)

# brms::get_prior(formula, data = data)
# brms::validate_prior(formula)

model_ebbinghaus_err <- brms::brm(formula,
  data = data,
  refresh = 0
)

# parameters::parameters(model_delboeuf_err)

save(model_ebbinghaus_err, file="models/model_ebbinghaus_err.Rdata")
```
```{r message=FALSE, warning=FALSE, cache=cache}
load("models/model_ebbinghaus_err.RData")
```


##### Model Visualization


```{r message=FALSE, warning=FALSE, cache=cache}
p_ebbinghaus_err <- plot_model_err(data, model_ebbinghaus_err)
p_ebbinghaus_err
```



#### Reaction Time

##### Descriptive

```{r message=FALSE, warning=FALSE, cache=cache}
data <- filter(df, Illusion_Type == "Ebbinghaus", Error == 0)

plot_descriptive_rt(data)
```


##### Model Specification

```{r message=FALSE, warning=FALSE, cache=cache, eval=runModels}
formula <- brms::bf(
  RT ~ sqrt(Illusion_Difference) * sqrt(abs(Illusion_Strength)) * Illusion_Effect +
    (1 | Participant),
  # sigma ~ t2(Illusion_Difference * Illusion_Strength) +
  #   (1 | Participant),
  family = "exgaussian"
)


model_ebbinghaus_rt <- brms::brm(formula,
  data = data,
  refresh = 0
)

plot_ppcheck(model_ebbinghaus_rt)
# performance::check_model(model_delboeuf_rt)
# parameters::parameters(model)

save(model_ebbinghaus_rt, file="models/model_ebbinghaus_rt.Rdata")
```
```{r message=FALSE, warning=FALSE, cache=cache}
load("models/model_ebbinghaus_rt.RData")
```


##### Model Visualization


```{r message=FALSE, warning=FALSE, cache=cache}
p_ebbinghaus_rt <- plot_model_rt(data, model_ebbinghaus_rt)
p_ebbinghaus_rt
```


### Rod and Frame

#### Model Selection

```{r message=FALSE, warning=FALSE, cache=cache}
data <- filter(df, Illusion_Type == "Rod-Frame")
```

```{r message=FALSE, warning=FALSE, cache=cache, eval=FALSE}
best_models(data)
```

#### Error Rate 

##### Descriptive

```{r message=FALSE, warning=FALSE, cache=cache}
plot_descriptive_err(data)
```


##### Model Specification

```{r message=FALSE, warning=FALSE, cache=cache, eval=runModels}
formula <- brms::bf(
  Error ~ sqrt(Illusion_Difference) * sqrt(abs(Illusion_Strength)) * Illusion_Effect +
    (1 + sqrt(Illusion_Difference) * sqrt(abs(Illusion_Strength)) * Illusion_Effect | Participant),
  family = "bernoulli"
)

# brms::get_prior(formula, data = data)
# brms::validate_prior(formula)

model_rodframe_err <- brms::brm(formula,
  data = data,
  refresh = 0
)

# parameters::parameters(model_delboeuf_err)

save(model_rodframe_err, file="models/model_rodframe_err.Rdata")
```
```{r message=FALSE, warning=FALSE, cache=cache}
load("models/model_rodframe_err.RData")
```


##### Model Visualization


```{r message=FALSE, warning=FALSE, cache=cache}
p_rodframe_err <- plot_model_err(data, model_rodframe_err)
p_rodframe_err
```


#### Reaction Time

##### Descriptive

```{r message=FALSE, warning=FALSE, cache=cache}
data <- filter(df, Illusion_Type == "Rod-Frame", Error == 0)

plot_descriptive_rt(data)
```


##### Model Specification

```{r message=FALSE, warning=FALSE, cache=cache, eval=runModels}
formula <- brms::bf(
  RT ~ sqrt(Illusion_Difference) * sqrt(abs(Illusion_Strength)) * Illusion_Effect +
    (1 | Participant),
  # sigma ~ t2(Illusion_Difference * Illusion_Strength) +
  #   (1 | Participant),
  family = "exgaussian"
)


model_rodframe_rt <- brms::brm(formula,
  data = data,
  refresh = 0
)

plot_ppcheck(model_rodframe_rt)
# performance::check_model(model_delboeuf_rt)
# parameters::parameters(model)

save(model_rodframe_rt, file="models/model_rodframe_rt.Rdata")
```
```{r message=FALSE, warning=FALSE, cache=cache}
load("models/model_rodframe_rt.RData")
```


##### Model Visualization


```{r message=FALSE, warning=FALSE, cache=cache}
p_rodframe_rt <- plot_model_rt(data, model_rodframe_rt)
p_rodframe_rt
```

### Vertical-Horizontal

#### Model Selection

```{r message=FALSE, warning=FALSE, cache=cache}
data <- filter(df, Illusion_Type == "Vertical-Horizontal") 
```

```{r message=FALSE, warning=FALSE, cache=cache, eval=FALSE}
best_models(data)
```


#### Error Rate 

##### Descriptive

```{r message=FALSE, warning=FALSE, cache=cache}
plot_descriptive_err(data)
```


##### Model Specification

```{r message=FALSE, warning=FALSE, cache=cache, eval=runModels}
formula <- brms::bf(
  Error ~ sqrt(Illusion_Difference) * sqrt(abs(Illusion_Strength)) * Illusion_Effect +
    (1 | Participant),
  family = "bernoulli"
)

# brms::get_prior(formula, data = data)
# brms::validate_prior(formula)

model_verticalhorizontal_err <- brms::brm(formula,
  data = data,
  refresh = 0
)

# parameters::parameters(model_verticalhorizontal_err)

save(model_verticalhorizontal_err, file="models/model_verticalhorizontal_err.Rdata")
```
```{r message=FALSE, warning=FALSE, cache=cache}
load("models/model_verticalhorizontal_err.RData")
```


##### Model Visualization


```{r message=FALSE, warning=FALSE, cache=cache}
p_verticalhorizontal_err <- plot_model_err(data, model_verticalhorizontal_err)
p_verticalhorizontal_err
```



#### Reaction Time

##### Descriptive

```{r message=FALSE, warning=FALSE, cache=cache}
data <- filter(df, Illusion_Type == "Vertical-Horizontal", Error == 0)

plot_descriptive_rt(data)
```


##### Model Specification

```{r message=FALSE, warning=FALSE, cache=cache, eval=runModels}
formula <- brms::bf(
  RT ~ sqrt(Illusion_Difference) * sqrt(abs(Illusion_Strength)) * Illusion_Effect +
    (1 | Participant),
  # sigma ~ t2(Illusion_Difference * Illusion_Strength) +
  #   (1 | Participant),
  family = "exgaussian"
)


model_verticalhorizontal_rt <- brms::brm(formula,
  data = data,
  refresh = 0
)

plot_ppcheck(model_verticalhorizontal_rt)
# performance::check_model(model_verticalhorizontal_rt)
# parameters::parameters(model)

save(model_verticalhorizontal_rt, file="models/model_verticalhorizontal_rt.Rdata")
```
```{r message=FALSE, warning=FALSE, cache=cache}
load("models/model_verticalhorizontal_rt.RData")
```



##### Model Visualization


```{r message=FALSE, warning=FALSE, cache=cache}
p_verticalhorizontal_rt <- plot_model_rt(data, model_verticalhorizontal_rt)
p_verticalhorizontal_rt
```



### Zöllner


#### Model Selection

```{r message=FALSE, warning=FALSE, cache=cache}
data <- filter(df, Illusion_Type == "Zöllner")
```

```{r message=FALSE, warning=FALSE, cache=cache, eval=FALSE}
best_models(data)
```

#### Error Rate 


##### Descriptive

```{r message=FALSE, warning=FALSE, cache=cache}
plot_descriptive_err(data)
```


##### Model Specification

```{r message=FALSE, warning=FALSE, cache=cache, eval=runModels}
formula <- brms::bf(
  Error ~ logmod(Illusion_Difference) * abs(Illusion_Strength) * Illusion_Effect +
    (1 | Participant),
  family = "bernoulli"
)

# brms::get_prior(formula, data = data)
# brms::validate_prior(formula)

model_zollner_err <- brms::brm(formula,
  data = data,
  refresh = 0
)

# parameters::parameters(model_zollner_err)

save(model_zollner_err, file="models/model_zollner_err.Rdata")
```
```{r message=FALSE, warning=FALSE, cache=cache}
load("models/model_zollner_err.RData")
```


##### Model Visualization


```{r message=FALSE, warning=FALSE, cache=cache}
p_zollner_err <- plot_model_err(data, model_zollner_err)
p_zollner_err
```


#### Reaction Time

##### Descriptive

```{r message=FALSE, warning=FALSE, cache=cache}
data <- filter(df, Illusion_Type == "Zöllner", Error == 0)

plot_descriptive_rt(data)
```



##### Model Specification

```{r message=FALSE, warning=FALSE, cache=cache, eval=runModels}
formula <- brms::bf(
  RT ~ logmod(Illusion_Difference) * abs(Illusion_Strength) * Illusion_Effect +
    (1 | Participant),
  # sigma ~ t2(Illusion_Difference * Illusion_Strength) +
  #   (1 | Participant),
  family = "exgaussian"
)


model_zollner_rt <- brms::brm(formula,
  data = data,
  refresh = 0
)

plot_ppcheck(model_zollner_rt)
# performance::check_model(model_zollner_rt)
# parameters::parameters(model)

save(model_zollner_rt, file="models/model_zollner_rt.Rdata")
```
```{r message=FALSE, warning=FALSE, cache=cache}
load("models/model_zollner_rt.RData")
```


##### Model Visualization


```{r message=FALSE, warning=FALSE, cache=cache}
p_zollner_rt <- plot_model_rt(data, model_zollner_rt)
p_zollner_rt
```



### White


```{r message=FALSE, warning=FALSE, cache=cache}
data <- filter(df, Illusion_Type == "White")
```

```{r message=FALSE, warning=FALSE, cache=cache, eval=FALSE}
best_models(data)
```

#### Error Rate 

##### Descriptive

```{r message=FALSE, warning=FALSE, cache=cache}
plot_descriptive_err(data)
```


##### Model Specification

```{r message=FALSE, warning=FALSE, cache=cache, eval=runModels}
formula <- brms::bf(
  Error ~ sqrt(Illusion_Difference) * sqrt(abs(Illusion_Strength)) * Illusion_Effect +
    (1 + sqrt(Illusion_Difference) * sqrt(abs(Illusion_Strength)) * Illusion_Effect | Participant),
  family = "bernoulli"
)

# brms::get_prior(formula, data = data)
# brms::validate_prior(formula)

model_white_err <- brms::brm(formula,
  data = data,
  refresh = 0
)

# parameters::parameters(model_white_err)

save(model_white_err, file="models/model_white_err.Rdata")
```
```{r message=FALSE, warning=FALSE, cache=cache}
load("models/model_white_err.RData")
```


##### Model Visualization


```{r message=FALSE, warning=FALSE, cache=cache}
p_white_err <- plot_model_err(data, model_white_err)
p_white_err
```



#### Reaction Time

##### Descriptive

```{r message=FALSE, warning=FALSE, cache=cache}
data <- filter(df, Illusion_Type == "White", Error == 0)

plot_descriptive_rt(data)
```

##### Model Specification

```{r message=FALSE, warning=FALSE, cache=cache, eval=runModels}
formula <- brms::bf(
  RT ~ sqrt(Illusion_Difference) * sqrt(abs(Illusion_Strength)) * Illusion_Effect +
    (1 | Participant),
  # sigma ~ t2(Illusion_Difference * Illusion_Strength) +
  #   (1 | Participant),
  family = "exgaussian"
)


model_white_rt <- brms::brm(formula,
  data = data,
  refresh = 0
)

plot_ppcheck(model_white_rt)
# performance::check_model(model_white_rt)
# parameters::parameters(model)

save(model_white_rt, file="models/model_white_rt.Rdata")
```
```{r message=FALSE, warning=FALSE, cache=cache}
load("models/model_white_rt.RData")
```


##### Model Visualization


```{r message=FALSE, warning=FALSE, cache=cache}
p_white_rt <- plot_model_rt(data, model_white_rt)
p_white_rt
```


### Müller-Lyer

#### Model Selection

```{r message=FALSE, warning=FALSE, cache=cache}
data <- filter(df, Illusion_Type == "Müller-Lyer")
```

```{r message=FALSE, warning=FALSE, cache=cache, eval=FALSE}
best_models(data)
```

#### Error Rate 

##### Descriptive

```{r message=FALSE, warning=FALSE, cache=cache}
plot_descriptive_err(data, side = "updown")
```



##### Model Specification

```{r message=FALSE, warning=FALSE, cache=cache, eval=runModels}
formula <- brms::bf(
  Error ~ logmod(Illusion_Difference) * sqrt(abs(Illusion_Strength)) * Illusion_Effect +
    (1 + logmod(Illusion_Difference) * sqrt(abs(Illusion_Strength)) * Illusion_Effect | Participant),
  family = "bernoulli"
)

# brms::get_prior(formula, data = data)
# brms::validate_prior(formula)

model_mullerlyer_err <- brms::brm(formula,
  data = data,
  refresh = 0
)

# parameters::parameters(model_white_err)

save(model_mullerlyer_err, file="models/model_mullerlyer_err.Rdata")
```
```{r message=FALSE, warning=FALSE, cache=cache}
load("models/model_mullerlyer_err.RData")
```

##### Model Visualization


```{r message=FALSE, warning=FALSE, cache=cache}
p_mullerlyer_err <- plot_model_err(data, model_mullerlyer_err)
p_mullerlyer_err
```

#### Reaction Time

##### Descriptive

```{r message=FALSE, warning=FALSE, cache=cache}
data <- filter(df, Illusion_Type == "Müller-Lyer", Error == 0)

plot_descriptive_rt(data, side = "updown")
```


##### Model Specification

```{r message=FALSE, warning=FALSE, cache=cache, eval=runModels}
formula <- brms::bf(
  RT ~ logmod(Illusion_Difference) * logmod(abs(Illusion_Strength)) * Illusion_Effect +
    (1 | Participant),
  # sigma ~ t2(Illusion_Difference * Illusion_Strength) +
  #   (1 | Participant),
  family = "exgaussian"
)


model_mullerlyer_rt <- brms::brm(formula,
  data = data,
  refresh = 0
)

plot_ppcheck(model_mullerlyer_rt)
# performance::check_model(model_mullerlyer_rt)
# parameters::parameters(model)

save(model_mullerlyer_rt, file="models/model_mullerlyer_rt.Rdata")
# parameters::parameters(model_white_err)
```
```{r message=FALSE, warning=FALSE, cache=cache}
load("models/model_mullerlyer_rt.RData")
```

##### Model Visualization


```{r message=FALSE, warning=FALSE, cache=cache}
p_mullerlyer_rt <- plot_model_rt(data, model_mullerlyer_rt)
p_mullerlyer_rt
```


### Ponzo

#### Model Selection

```{r message=FALSE, warning=FALSE, cache=cache}
data <- filter(df, Illusion_Type == "Ponzo")
```

```{r message=FALSE, warning=FALSE, cache=cache, eval=FALSE}
best_models(data)
```

#### Error Rate 


##### Descriptive

```{r message=FALSE, warning=FALSE, cache=cache}
plot_descriptive_err(data, side = "updown")
```


##### Model Specification

```{r message=FALSE, warning=FALSE, cache=cache, eval=runModels}
formula <- brms::bf(
  Error ~ sqrt(Illusion_Difference) * abs(Illusion_Strength) * Illusion_Effect +
    (1 | Participant),
  family = "bernoulli"
)

# brms::get_prior(formula, data = data)
# brms::validate_prior(formula)

model_ponzo_err <- brms::brm(formula,
  data = data,
  refresh = 0
)

# parameters::parameters(model_ponzo_err)

save(model_ponzo_err, file="models/model_ponzo_err.Rdata")
```
```{r message=FALSE, warning=FALSE, cache=cache}
load("models/model_ponzo_err.RData")
```

##### Model Visualization


```{r message=FALSE, warning=FALSE, cache=cache}
p_ponzo_err <- plot_model_err(data, model_ponzo_err)
p_ponzo_err
```


#### Reaction Time

##### Descriptive

```{r message=FALSE, warning=FALSE, cache=cache}
data <- filter(df, Illusion_Type == "Ponzo", Error == 0)

plot_descriptive_rt(data, side = "updown")
```


##### Model Specification

```{r message=FALSE, warning=FALSE, cache=cache, eval=runModels}
formula <- brms::bf(
  RT ~ sqrt(Illusion_Difference) * abs(Illusion_Strength) * Illusion_Effect +
    (1 | Participant),
  # sigma ~ t2(Illusion_Difference * Illusion_Strength) +
  #   (1 | Participant),
  family = "exgaussian"
)


model_ponzo_rt <- brms::brm(formula,
  data = data,
  refresh = 0
)

plot_ppcheck(model_ponzo_rt)
# performance::check_model(model_ponzo_rt)
# parameters::parameters(model)

save(model_ponzo_rt, file="models/model_ponzo_rt.Rdata")
# parameters::parameters(model_white_err)
```
```{r message=FALSE, warning=FALSE, cache=cache}
load("models/model_ponzo_rt.RData")
```

##### Model Visualization


```{r message=FALSE, warning=FALSE, cache=cache}
p_ponzo_rt <- plot_model_rt(data, model_ponzo_rt)
p_ponzo_rt
```


### Poggendorff

#### Model Selection

```{r message=FALSE, warning=FALSE, cache=cache}
data <- filter(df, Illusion_Type == "Poggendorff")
```

```{r message=FALSE, warning=FALSE, cache=cache, eval=FALSE}
best_models(data)
```


#### Error Rate 

##### Descriptive

```{r message=FALSE, warning=FALSE, cache=cache}
plot_descriptive_err(data, side = "updown")
```

##### Model Specification

```{r message=FALSE, warning=FALSE, cache=cache, eval=runModels}
formula <- brms::bf(
  Error ~ cbrtmod(Illusion_Difference) * sqrt(abs(Illusion_Strength)) * Illusion_Effect +
    (1 | Participant),
  family = "bernoulli"
)

# brms::get_prior(formula, data = data)
# brms::validate_prior(formula)

model_poggendorff_err <- brms::brm(formula,
  data = data,
  refresh = 0
)

# parameters::parameters(model_poggendorff_err)

save(model_poggendorff_err, file="models/model_poggendorff_err.Rdata")
```
```{r message=FALSE, warning=FALSE, cache=cache}
load("models/model_poggendorff_err.RData")
```

##### Model Visualization


```{r message=FALSE, warning=FALSE, cache=cache}
p_poggendorff_err <- plot_model_err(data, model_poggendorff_err)
p_poggendorff_err
```


#### Reaction Time

##### Descriptive

```{r message=FALSE, warning=FALSE, cache=cache}
data <- filter(df, Illusion_Type == "Poggendorff", Error == 0)

plot_descriptive_rt(data, side = "updown")
```

##### Model Specification

```{r message=FALSE, warning=FALSE, cache=cache, eval=runModels}
formula <- brms::bf(
  RT ~ cbrtmod(Illusion_Difference) * sqrt(abs(Illusion_Strength)) * Illusion_Effect +
    (1 | Participant),
  # sigma ~ 1 + (1 | Participant),
  family = "exgaussian"
)


model_poggendorff_rt <- brms::brm(formula,
  data = data,
  refresh = 0
)

plot_ppcheck(model_poggendorff_rt)
# performance::check_model(model_poggendorff_rt)
# parameters::parameters(model)

save(model_ponzo_rt, file="models/model_poggendorff_rt.Rdata")
```
```{r message=FALSE, warning=FALSE, cache=cache}
load("models/model_poggendorff_rt.RData")
```

##### Model Visualization


```{r message=FALSE, warning=FALSE, cache=cache}
p_poggendorff_rt <- plot_model_rt(data, model_poggendorff_rt)
p_poggendorff_rt
```



### Contrast

#### Model Selection


```{r message=FALSE, warning=FALSE, cache=cache}
data <- filter(df, Illusion_Type == "Contrast")
```

```{r message=FALSE, warning=FALSE, cache=cache, eval=FALSE}
best_models(data)
```


#### Error Rate 

##### Descriptive

```{r message=FALSE, warning=FALSE, cache=cache}
data <- filter(df, Illusion_Type == "Contrast")

plot_descriptive_err(data, side = "updown")
```


##### Model Specification

```{r message=FALSE, warning=FALSE, cache=cache, eval=runModels}
formula <- brms::bf(
  Error ~ sqrt(Illusion_Difference) * sqrt(abs(Illusion_Strength)) * Illusion_Effect +
    (1 + sqrt(Illusion_Difference) * sqrt(abs(Illusion_Strength)) * Illusion_Effect | Participant),
  family = "bernoulli"
)

# brms::get_prior(formula, data = data)
# brms::validate_prior(formula)

model_contrast_err <- brms::brm(formula,
  data = data,
  refresh = 0
)

# parameters::parameters(model_contrast_err)

save(model_contrast_err, file="models/model_contrast_err.Rdata")
```
```{r message=FALSE, warning=FALSE, cache=cache}
load("models/model_contrast_err.RData")
```

##### Model Visualization


```{r message=FALSE, warning=FALSE, cache=cache}
p_contrast_err <- plot_model_err(data, model_contrast_err)
p_contrast_err
```



#### Reaction Time

##### Descriptive

```{r message=FALSE, warning=FALSE, cache=cache}
data <- filter(df, Illusion_Type == "Contrast", Error == 0)

plot_descriptive_rt(data, side = "updown")
```

##### Model Specification

```{r message=FALSE, warning=FALSE, cache=cache, eval=runModels}
formula <- brms::bf(
  RT ~ sqrt(Illusion_Difference) * sqrt(abs(Illusion_Strength)) * Illusion_Effect +
    (1 | Participant),
  # sigma ~ 1 + (1 | Participant),
  family = "exgaussian"
)


model_contrast_rt <- brms::brm(formula,
  data = data,
  refresh = 0
)

plot_ppcheck(model_contrast_rt)
# performance::check_model(model_contrast_rt)
# parameters::parameters(model)

save(model_contrast_rt, file="models/model_contrast_rt.Rdata")
```
```{r message=FALSE, warning=FALSE, cache=cache}
load("models/model_contrast_rt.RData")
```

##### Model Visualization


```{r message=FALSE, warning=FALSE, cache=cache}
p_contrast_rt <- plot_model_rt(data, model_contrast_rt)
p_contrast_rt
```



## Individual Scores

### Delboeuf 

#### Reliability


```{r message=FALSE, warning=FALSE, cache=cache}
random <- rbind(
  extract_random(model_delboeuf_err, "Delboeuf"),
  # extract_random(model_delboeuf_rt, "Delboeuf"),
  extract_random(model_ebbinghaus_err, "Ebbinghaus"),
  # extract_random(model_ebbinghaus_rt, "Ebbinghaus"),
  extract_random(model_rodframe_err, "Rod-Frame"),
  # extract_random(model_rodframe_rt, "Rod-Frame"),
  extract_random(model_verticalhorizontal_err, "Vertical-Horizontal"),
  # extract_random(model_verticalhorizontal_rt, "Vertical-Horizontal"),
  extract_random(model_zollner_err, "Zöllner"),
  # extract_random(model_zollner_rt, "Zöllner"),
  extract_random(model_white_err, "White"),
  # extract_random(model_white_rt, "White"),
  extract_random(model_mullerlyer_err, "Müller-Lyer"),
  # extract_random(model_mullerlyer_rt, "Müller-Lyer"),
  extract_random(model_ponzo_err, "Ponzo"),
  # extract_random(model_ponzo_rt, "Ponzo"),
  extract_random(model_poggendorff_err, "Poggendorff"),
  # extract_random(model_poggendorff_rt, "Poggendorff"),
  # extract_random(model_contrast_err, "Contrast")
  # extract_random(model_contrast_rt, "Contrast")
) |> 
  filter(
    # !str_detect(Parameter, "Intercept_"),
    !str_detect(Parameter, "Cong_"),
    !str_detect(Parameter, "Null_"))


random |>
  # group_by(Illusion_Type, Parameter) |> 
  # standardize(select="Value") |> 
  # ungroup() |> 
  # mutate(order = mean(Value)) |> 
  # ungroup() |> 
  # mutate(Participant = fct_reorder(Participant, order)) |> 
  ggplot(aes(y = Participant, x = Value)) +
  ggdist::stat_slabinterval(aes(fill = Illusion_Type, color=Illusion_Type), alpha=0.5) +
  # coord_cartesian(xlim=c(-4, 4)) +
  facet_wrap(~Parameter, scales = "free_x") 



random <- random |>
  mutate(Parameter = paste0(Illusion_Type, "_", Parameter),
         Parameter = str_replace(Parameter, "Rod-Frame", "RodFrame"),
         Parameter = str_replace(Parameter, "Vertical-Horizontal", "VerticalHorizontal"),
         Parameter = str_replace(Parameter, "Zöllner", "Zollner")) |>
  group_by(Participant, Parameter) |>
  summarize(Score = as.numeric(bayestestR::map_estimate(Value)), .groups = "drop") |>
  ungroup() |>
  group_by(Parameter) |> 
  mutate(Score = Score / sd(Score)) |>  # Scale
  ungroup()  |> 
  pivot_wider(names_from = Parameter, values_from = Score)

# plot(estimate_density(select(random, -Participant)))
```


<!-- #### Approximation -->

<!-- ```{r message=FALSE, warning=FALSE, cache=cache} -->
<!-- dat <- data.frame() -->
<!-- for (participant in unique(data$Participant)) { -->
<!--   freq <- glm(Error ~ Illusion_Difference * Illusion_Strength, -->
<!--     family = "binomial", -->
<!--     data = filter( -->
<!--       df, Participant == participant, -->
<!--       Illusion_Type == "Delboeuf" -->
<!--     ) -->
<!--   ) -->

<!--   parameters::parameters(freq)[1:2] |> -->
<!--     as.data.frame() |> -->
<!--     mutate( -->
<!--       Participant = participant, -->
<!--       Parameter = paste0("freq_Delboeuf_", Parameter) -->
<!--     ) -->
<!-- } -->
<!-- ``` -->



## Structure

### Correlation 

```{r message=FALSE, warning=FALSE, cache=cache}
clean_name <- function(x) {
  x |>
    str_replace("_Loc", " (loc)") |>
    str_replace("_Disp", " (disp)") |>
    str_replace("_Prob", " (prob)") |>
    str_replace("_", " - ")
}

cor <- correlation::correlation(random, redundant = TRUE)

p_data <- cor |>
  mutate(
    Parameter1 = clean_name(Parameter1),
    Parameter2 = clean_name(Parameter2)
  ) |>
  correlation::cor_sort(hclust_method = "ward.D2") |>
  cor_lower() |>
  mutate(
    Text = insight::format_value(r, zap_small = TRUE, digits = 3),
    Text = str_replace(str_remove(Text, "^0+"), "^-0+", "-"),
    Parameter2 = fct_rev(Parameter2)
  )


p_data |>
  ggplot(aes(x = Parameter2, y = Parameter1)) +
  geom_tile(aes(fill = r)) +
  # geom_text(aes(label = Text), size = 2) +
  scale_fill_gradient2(low = "#2196F3", mid = "white", high = "#F44336", midpoint = 0, limit = c(-1, 1), space = "Lab", name = "Correlation", guide = "legend") +
  scale_x_discrete(expand = c(0, 0)) +
  scale_y_discrete(expand = c(0, 0)) +
  labs(title = "Correlation Matrix", x = NULL, y = NULL) +
  theme_minimal() +
  theme(
    axis.text.x = element_text(angle = 90, hjust = 1),
    plot.title = element_text(hjust = 0.5, face = "bold"),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  )
```

### Factor Analysis

#### First Level

```{r message=FALSE, warning=FALSE, cache=cache}
data <- select(random, -Participant)

rez <- parameters::n_factors(data)
plot(rez)


fa <- parameters::factor_analysis(data,
  cor = as.matrix(cor),
  n = 5,
  rotation = "oblimin",
  fm = "mle",
  sort = TRUE
)

# psych::omega(data, nfactors=3)
# fa <- psych::fa.multi(as.matrix(cor), nfactors = 3, nfact2 = 1, n.obs = nrow(random))
# psych::fa.multi.diagram(fa)
```

#### Second Level

```{r message=FALSE, warning=FALSE, cache=cache}
data <- predict(fa)

rez <- parameters::n_factors(data, rotation = "oblimin")
plot(rez)

fa2 <- parameters::factor_analysis(data,
  n = 2,
  rotation = "varimax",
  fm = "mle",
  sort = TRUE
)

# psych::schmid(attributes(fa)$model, nfactors = 1)
```


#### Visualization
```{r message=FALSE, warning=FALSE, cache=cache}
library(ggraph)

dat <- rbind(
  attributes(fa)$loadings_long,
  attributes(fa2)$loadings_long |>
    mutate(Component = str_replace(Component, "ML", "G"))
) |>
  tidygraph::as_tbl_graph() |>
  tidygraph::activate("nodes")


# Get order of indices
# idx <- correlation::cor_sort(cor, hclust_method = "ward.D2") |>
#   summary() |>
#   pull(Parameter)
# idx <- sort(fa$Variable)
idx <- fa$Variable

get_x <- function(name, x) {
  case_when(
    name == "G1" ~ 0/1,
    name == "G2" ~ 1/1,
    name == "ML1" ~ 0/4,
    name == "ML2" ~ 1/4,
    name == "ML3" ~ 2/4,
    name == "ML4" ~ 3/4,
    name == "ML5" ~ 4/4,
    TRUE ~ x)
}

dat |>
  mutate(
    x = sapply(as.data.frame(dat)$name, function(x) {
      if (x %in% idx) {
        (which(idx == x) - 1) / (length(idx) - 1)
      } else {
        NA
      }
    })
  ) |>
  mutate(
    x = get_x(name, x),
    y = case_when(
    str_detect(name, "G") ~ 2,
    str_detect(name, "ML") ~ 1,
    TRUE ~ 0),
    angle = ifelse(name %in% idx, 90, 0),
    hjust = ifelse(name %in% idx, 1.01, 0),
    name = clean_name(name),
    Illusion_Type = str_split_fixed(name, " - ", n=2)[, 1]) |> 
  tidygraph::activate("edges") |> 
  filter(abs(Loading) > 0.2) |> 
  ggraph(layout = "nicely") +
  geom_edge_link(aes(edge_width = Loading, edge_colour = as.factor(sign(Loading)))) +
  geom_node_point(aes(color = Illusion_Type), size=3) +
  geom_node_text(aes(label = name, angle = angle, hjust=hjust)) +
  scale_y_continuous(expand = expansion(c(.6, .1))) +
  scale_edge_width_continuous(range=c(0.1, 1)) +
  scale_edge_color_manual(values=c("#F44336", "#2196F3")) +
  scale_color_manual(values=c("Delboeuf" = "#F44336", Ebbinghaus = "#E91E63",
                              "Rod-Frame" = "#9C27B0")) +
  guides(edge_colour = "none") +
  ggraph::theme_graph()
```

### SEM

```{r message=FALSE, warning=FALSE, cache=cache}
library(lavaan)
library(tidySEM)


names <- names(select(random, -Participant))
data <- setNames(as.data.frame(str_split_fixed(names, "_", 3)), c("Illusion_Type", "Parameter", "Model"))
data$Name <- names

# Model 1
lvl1 <- paste(data$Illusion_Type, "=~", data$Name)
lvl2 <- paste("G =~", unique(data$Illusion_Type))
resid <- as.data.frame(t(utils::combn(x=unique(data$Illusion_Type), 2)))
resid <- paste(resid$V1, "~~", resid$V2)[1:2]



m1 <- sem(model = paste0(c(lvl1, lvl2, resid), collapse = "\n"),
           data  = random)


# Model 2
lvl1 <- paste(data$Model, "=~", data$Name)
lvl2 <- paste("G =~", unique(data$Model))

m2 <- sem(model = paste0(c(lvl1, lvl2), collapse = "\n"),
           data  = random)

# Model 3
lvl1 <- paste(data$Parameter, "=~", data$Name)
lvl2 <- paste("G =~", unique(data$Parameter))

m3 <- sem(model = paste0(c(lvl1, lvl2), collapse = "\n"),
           data  = random)

anova(m1, m2, m3)

summary(m1, standardize = TRUE)

tidySEM::graph_sem(model = m1)

# as_tbl_graph(fit, standardize = TRUE)
```


```{r message=FALSE, warning=FALSE, cache=cache}
# Save
dfsub <- dfsub |> 
  merge(random, by = "Participant") |> 
  cbind(data, predict(fa2, names=c("G1", "G2")))

write.csv("../data/study3.csv")
```

